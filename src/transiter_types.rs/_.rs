// This file is @generated by prost-build.
/// Request payload for the entrypoint endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrypointRequest {}
/// Response payload for the entrypoint endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrypointReply {
    /// Version and other information about this Transiter binary.
    #[prost(message, optional, tag = "1")]
    pub transiter: ::core::option::Option<entrypoint_reply::TransiterDetails>,
    /// Systems that are installed in this Transiter instance.
    #[prost(message, optional, tag = "2")]
    pub systems: ::core::option::Option<ChildResources>,
}
/// Nested message and enum types in `EntrypointReply`.
pub mod entrypoint_reply {
    /// Message containing version information about a Transiter binary.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransiterDetails {
        /// The version of the Transiter binary this instance is running.
        #[prost(string, tag = "1")]
        pub version: ::prost::alloc::string::String,
        /// URL of the Transiter GitHub repository.
        #[prost(string, tag = "4")]
        pub url: ::prost::alloc::string::String,
    }
}
/// Request payload for the list systems endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSystemsRequest {}
/// Response payload for the list systems endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSystemsReply {
    /// List of systems.
    #[prost(message, repeated, tag = "1")]
    pub systems: ::prost::alloc::vec::Vec<System>,
}
/// Request payload for the get system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemRequest {
    /// ID of the system to get.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Request payload for the list agencies endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgenciesRequest {
    /// ID of the system for which to list agencies.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list agencies endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgenciesReply {
    /// List of agencies.
    #[prost(message, repeated, tag = "1")]
    pub agencies: ::prost::alloc::vec::Vec<Agency>,
}
/// Request payload for the get agency endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgencyRequest {
    /// ID of the system the agency is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the agency.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub agency_id: ::prost::alloc::string::String,
}
/// Request payload for the list stops endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStopsRequest {
    /// ID of the system for which to list stops.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// The type of search to perform when listing stops.
    #[prost(enumeration = "list_stops_request::SearchMode", optional, tag = "13")]
    pub search_mode: ::core::option::Option<i32>,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "8")]
    pub only_return_specified_ids: bool,
    /// If true, only return stops whose IDs are specified in the repeated `id` field.
    /// Only supported when the search mode is ID.
    #[prost(bool, tag = "15")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true.
    /// It is an error to populate this field if `filter_by_id` is false.
    /// Only supported when the search mode is ID.
    #[prost(string, repeated, tag = "9")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, only return stops whose types are specified in the repeated `type` field.
    #[prost(bool, tag = "16")]
    pub filter_by_type: bool,
    /// Types to filter by if `filter_by_type` is set to true.
    /// It is an error to populate this field if `filter_by_id` is false.
    #[prost(enumeration = "stop::Type", repeated, tag = "17")]
    pub r#type: ::prost::alloc::vec::Vec<i32>,
    /// ID of the first stop to return. If not set, the stop with the smallest ID will be first.
    /// Only supported when the search mode is ID.
    #[prost(string, optional, tag = "2")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of stops to return.
    /// This is supported in all search modes.
    /// For performance reasons, if it is larger than 100 it is rounded down to 100.
    #[prost(int32, optional, tag = "3")]
    pub limit: ::core::option::Option<i32>,
    /// If true, the stop times field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_stop_times: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "6")]
    pub skip_alerts: bool,
    /// If true, the transfers field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "7")]
    pub skip_transfers: bool,
    /// The maximum distance in kilometers that a stop must be from
    /// latitude, longitude to be listed when using DISTANCE search mode.
    #[prost(double, optional, tag = "10")]
    pub max_distance: ::core::option::Option<f64>,
    /// The latitude relative to the returned stops when using DISTANCE search mode.
    #[prost(double, optional, tag = "11")]
    pub latitude: ::core::option::Option<f64>,
    /// The longitude relative to the returned stops when using DISTANCE search mode.
    #[prost(double, optional, tag = "12")]
    pub longitude: ::core::option::Option<f64>,
}
/// Nested message and enum types in `ListStopsRequest`.
pub mod list_stops_request {
    /// The possible search modes when listing stops.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchMode {
        /// Return a paginated list of stops sorted by stop ID.
        Id = 0,
        /// Return all stops within max_distance of (latitude, longitude), sorted by the distance.
        Distance = 1,
    }
    impl SearchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchMode::Id => "ID",
                SearchMode::Distance => "DISTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID" => Some(Self::Id),
                "DISTANCE" => Some(Self::Distance),
                _ => None,
            }
        }
    }
}
/// Response payload for the list stops endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStopsReply {
    /// List of stops.
    #[prost(message, repeated, tag = "1")]
    pub stops: ::prost::alloc::vec::Vec<Stop>,
    /// ID of the next stop to return, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get stop endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStopRequest {
    /// ID of the system the stop is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the stop.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub stop_id: ::prost::alloc::string::String,
    /// If true, the stop times field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_stop_times: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "6")]
    pub skip_alerts: bool,
    /// If true, the transfers field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "7")]
    pub skip_transfers: bool,
}
/// Request payload for the list routes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesRequest {
    /// ID of the system for which to list routes.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If true, the estimated headway fields will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "2")]
    pub skip_estimated_headways: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "3")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_alerts: bool,
}
/// Response payload for the list routes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesReply {
    /// List of routes.
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
}
/// Request payload for the get route endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRouteRequest {
    /// ID of the system the route is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
    /// If true, the estimated headway field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "3")]
    pub skip_estimated_headways: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_alerts: bool,
}
/// Request payload for the list trips endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTripsRequest {
    /// ID of the system the route is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route for which to list trips
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
}
/// Response payload for the list trips endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTripsReply {
    /// List of trips.
    #[prost(message, repeated, tag = "1")]
    pub trips: ::prost::alloc::vec::Vec<Trip>,
}
/// Request payload for the list alerts endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertsRequest {
    /// ID of the system for which to list alerts.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If non-empty, only alerts with the provided IDs are returned.
    /// This is interpreted as a filtering condition, so it is not an error to provide non-existent IDs.
    ///
    /// If empty, all alerts in the system are returned.
    /// TODO: add a boolean filter_on_alert_ids field
    #[prost(string, repeated, tag = "2")]
    pub alert_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response payload for the list alerts endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertsReply {
    /// List of alerts.
    #[prost(message, repeated, tag = "1")]
    pub alerts: ::prost::alloc::vec::Vec<Alert>,
}
/// Request payload for the get alert endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAlertRequest {
    /// ID of the system the alert is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the alert.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub alert_id: ::prost::alloc::string::String,
}
/// Request payload for the get trip endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTripRequest {
    /// ID of the system the trip is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route the trip is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
    /// ID of the route.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "3")]
    pub trip_id: ::prost::alloc::string::String,
}
/// Request payload for the list feeds endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedsRequest {
    /// ID of the system for which to list feeds.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list feeds endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedsReply {
    /// List of feeds.
    #[prost(message, repeated, tag = "1")]
    pub feeds: ::prost::alloc::vec::Vec<Feed>,
}
/// Request payload for the get feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedRequest {
    /// ID of the system the feed is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the feed.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub feed_id: ::prost::alloc::string::String,
}
/// Request payload for the list transfers endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersRequest {
    /// ID of the system for which to list transfers.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list transfers endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersReply {
    /// List of transfers.
    #[prost(message, repeated, tag = "1")]
    pub transfers: ::prost::alloc::vec::Vec<Transfer>,
}
/// Request payload for the get transfer endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransferRequest {
    /// ID of the system the transfer is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the transfer.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub transfer_id: ::prost::alloc::string::String,
}
/// Request payload for the list vehicles endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVehiclesRequest {
    /// ID of the system for which to list vehicles.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// The type of search to perform when listing vehicles.
    #[prost(enumeration = "list_vehicles_request::SearchMode", optional, tag = "2")]
    pub search_mode: ::core::option::Option<i32>,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub only_return_specified_ids: bool,
    /// If true, only return vehicles whose IDs are specified in the repeated `id` field.
    /// Only supported when the search mode is ID.
    #[prost(bool, tag = "10")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true. It is an error to
    /// populate this field if `filter_by_id` is false.
    /// Only supported when the search mode is ID.
    #[prost(string, repeated, tag = "4")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ID of the first vehicle to return. If not set, the vehicle with the smallest ID will be first.
    /// Only supported when the search mode is ID.
    #[prost(string, optional, tag = "5")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of vehicles to return.
    /// This is supported in all search modes.
    /// For performance reasons, if it is larger than 100 it is rounded down to 100.
    #[prost(int32, optional, tag = "6")]
    pub limit: ::core::option::Option<i32>,
    /// The maximum distance in kilometers that a vehicle must be from
    /// latitude, longitude to be listed when using DISTANCE search mode.
    #[prost(double, optional, tag = "7")]
    pub max_distance: ::core::option::Option<f64>,
    /// The latitude relative to the returned vehicles when using DISTANCE search mode.
    #[prost(double, optional, tag = "8")]
    pub latitude: ::core::option::Option<f64>,
    /// The longitude relative to the returned vehicles when using DISTANCE search mode.
    #[prost(double, optional, tag = "9")]
    pub longitude: ::core::option::Option<f64>,
}
/// Nested message and enum types in `ListVehiclesRequest`.
pub mod list_vehicles_request {
    /// Available search modes when listing vehicles.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchMode {
        /// Return a paginated list of vehicles sorted by vehicle ID.
        Id = 0,
        /// Return all vehicles within max_distance of (latitude, longitude), sorted by the distance.
        Distance = 1,
    }
    impl SearchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchMode::Id => "ID",
                SearchMode::Distance => "DISTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID" => Some(Self::Id),
                "DISTANCE" => Some(Self::Distance),
                _ => None,
            }
        }
    }
}
/// Response payload for the list vehicles endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVehiclesReply {
    /// List of vehicles.
    #[prost(message, repeated, tag = "1")]
    pub vehicles: ::prost::alloc::vec::Vec<Vehicle>,
    /// ID of the next vehicle to return, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get vehicle endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVehicleRequest {
    /// ID of the system the vehicle is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the vehicle.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub vehicle_id: ::prost::alloc::string::String,
}
/// Request payload for the list shapes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListShapesRequest {
    /// System to list shapes for.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub only_return_specified_ids: bool,
    /// If true, only return shapes whose IDs are specified in the repeated `id` field.
    #[prost(bool, tag = "6")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true. It is an error to
    /// populate this field if `filter_by_id` is false.
    #[prost(string, repeated, tag = "3")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ID of the first shape to return. If not set, the shape with the smallest ID will be first.
    #[prost(string, optional, tag = "4")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of shapes to return.
    #[prost(int32, optional, tag = "5")]
    pub limit: ::core::option::Option<i32>,
}
/// Response payload for the list shapes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListShapesReply {
    /// Shapes that were listed.
    #[prost(message, repeated, tag = "1")]
    pub shapes: ::prost::alloc::vec::Vec<Shape>,
    /// ID of the next shape to list, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get shape endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShapeRequest {
    /// System to get shape for.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the shape to get.
    #[prost(string, tag = "2")]
    pub shape_id: ::prost::alloc::string::String,
}
/// The System resource.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct System {
    /// ID of the system as specified in the install request.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the system resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// Name of the system as specified in the system configuration file.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Status of the system.
    #[prost(enumeration = "system::Status", tag = "5")]
    pub status: i32,
    /// The system's agencies.
    #[prost(message, optional, tag = "6")]
    pub agencies: ::core::option::Option<ChildResources>,
    /// The system's feeds.
    #[prost(message, optional, tag = "7")]
    pub feeds: ::core::option::Option<ChildResources>,
    /// The system's routes.
    #[prost(message, optional, tag = "8")]
    pub routes: ::core::option::Option<ChildResources>,
    /// The system's stops.
    #[prost(message, optional, tag = "9")]
    pub stops: ::core::option::Option<ChildResources>,
    /// The system's transfers.
    #[prost(message, optional, tag = "10")]
    pub transfers: ::core::option::Option<ChildResources>,
}
/// Nested message and enum types in `System`.
pub mod system {
    /// Reference type for the system resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
    /// Enum describing the possible statuses of a system.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Unknown status, included for protobuf reasons.
        Unknown = 0,
        /// The system is currently being installed through an asynchronous install request.
        Installing = 1,
        /// The system was successfully installed and is now active.
        Active = 2,
        /// The system was added through an asynchronous install request, but the install failed.
        InstallFailed = 3,
        /// The system is currently being updated through an asynchronous update request.
        Updating = 4,
        /// An asynchronous update of the system failed.
        UpdateFailed = 5,
        /// The system is in the process of being deleted through an asynchronous delete request.
        Deleting = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unknown => "UNKNOWN",
                Status::Installing => "INSTALLING",
                Status::Active => "ACTIVE",
                Status::InstallFailed => "INSTALL_FAILED",
                Status::Updating => "UPDATING",
                Status::UpdateFailed => "UPDATE_FAILED",
                Status::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INSTALLING" => Some(Self::Installing),
                "ACTIVE" => Some(Self::Active),
                "INSTALL_FAILED" => Some(Self::InstallFailed),
                "UPDATING" => Some(Self::Updating),
                "UPDATE_FAILED" => Some(Self::UpdateFailed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// This message contains generic metadata that applies to all resources.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    /// Full path of the resource.
    /// For example, for systems this is `systems/<system_id>`
    /// and for routes it is `systems/<system_id>/routes/<route_id>`.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// URL of the resource.
    /// This is populated if the `X-Transiter-Host` HTTP header is provided in the request.
    /// See [the deployment documentation](../deployment.md#optional-setting-the-transiter-host) for more information
    /// about this header.
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Description of a collection of child resources for a resource.
/// This message only exists to support API discoverability.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildResources {
    /// Number of child resources.
    #[prost(int64, tag = "1")]
    pub count: i64,
    /// Full path of the child resources.
    /// For example, for routes this is `systems/<system_id>/routes`
    /// and for trips it is `systems/<system_id>/routes/<route_id>/trips`.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// URL of the endpoint to list child resources.
    /// This is populated if the `X-Transiter-Host` HTTP header is provided in the request.
    /// See [the deployment documentation](../deployment.md#optional-setting-the-transiter-host) for more information.
    #[prost(string, optional, tag = "4")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
/// The Stop resource.
///
/// This resource corresponds to the [stop type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#stopstxt>).
/// Most of the static fields in the resource come directly from the `stops.txt` table.
/// Transiter adds some additional related fields (transfers, alerts, stop times)
///    and computed fields (service maps).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stop {
    /// ID of the stop. This is the `stop_id` column in `stops.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the stop resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this stop.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Code of the stop. This is the `stop_code` column in `stops.txt`.
    #[prost(string, optional, tag = "4")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the stop. This is the `stop_name` column in `stops.txt`.
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Description of the stop. This is the `stop_desc` column in `stops.txt`.
    #[prost(string, optional, tag = "6")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Zone ID of the stop. This is the `zone_id` column in `stops.txt`.
    #[prost(string, optional, tag = "7")]
    pub zone_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Latitude of the stop. This is the `stop_lat` column in `stops.txt`.
    #[prost(double, optional, tag = "8")]
    pub latitude: ::core::option::Option<f64>,
    /// Longitude of the stop. This is the `stop_lon` column in `stops.txt`.
    #[prost(double, optional, tag = "9")]
    pub longitude: ::core::option::Option<f64>,
    /// URL of a webpage about the stop. This is the `stop_url` column in `stops.txt`.
    #[prost(string, optional, tag = "10")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of the stop. This is the `platform_type` column in `stops.txt`.
    #[prost(enumeration = "stop::Type", tag = "11")]
    pub r#type: i32,
    /// Parent stop. This is determined using the `parent_station` column in `stops.txt`.
    #[prost(message, optional, tag = "12")]
    pub parent_stop: ::core::option::Option<stop::Reference>,
    /// Child stops. This are determined using the `parent_station` column in `stops.txt`.
    #[prost(message, repeated, tag = "13")]
    pub child_stops: ::prost::alloc::vec::Vec<stop::Reference>,
    /// Timezone of the stop. This is the `stop_timezone` column in `stops.txt`.
    #[prost(string, optional, tag = "14")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
    /// If there is wheelchair boarding for this stop. This is the `wheelchair_boarding` column in `stops.txt`.
    #[prost(bool, optional, tag = "15")]
    pub wheelchair_boarding: ::core::option::Option<bool>,
    /// Platform code of the stop. This is the `platform_code` column in `stops.txt`.
    #[prost(string, optional, tag = "16")]
    pub platform_code: ::core::option::Option<::prost::alloc::string::String>,
    /// List of service maps for this stop.
    #[prost(message, repeated, tag = "17")]
    pub service_maps: ::prost::alloc::vec::Vec<stop::ServiceMap>,
    /// Active alerts for this stop.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/reference/#message-alert>).
    #[prost(message, repeated, tag = "18")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
    /// List of realtime stop times for this stop.
    ///
    /// A stop time is an event at which a trip calls at a stop.
    #[prost(message, repeated, tag = "19")]
    pub stop_times: ::prost::alloc::vec::Vec<StopTime>,
    /// Transfers out of this stop.
    ///
    /// These are determined using the `from_stop_id` field in the GTFS static `transfers.txt` file.
    #[prost(message, repeated, tag = "20")]
    pub transfers: ::prost::alloc::vec::Vec<Transfer>,
    /// List of headsign rules for this stop.
    /// See the message type for more information.
    #[prost(message, repeated, tag = "21")]
    pub headsign_rules: ::prost::alloc::vec::Vec<stop::HeadsignRule>,
}
/// Nested message and enum types in `Stop`.
pub mod stop {
    /// Message describing the service maps view in stops.
    ///
    /// See the [service maps documentation](../systems.md#service-maps) for more information on this
    /// message and the associated field.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceMap {
        /// Config ID of the service map, as specified in the system configuration file.
        #[prost(string, tag = "1")]
        pub config_id: ::prost::alloc::string::String,
        /// List of routes which call at this stop.
        ///
        /// This list may be empty, in which case the stop has no service in the service map.
        #[prost(message, repeated, tag = "2")]
        pub routes: ::prost::alloc::vec::Vec<super::route::Reference>,
    }
    /// Message describing a headsign rule.
    ///
    /// This message is currently only used for the New York City subway.
    /// The data in it comes from the MTA's [subway stations feed](<https://data.ny.gov/Transportation/MTA-Subway-Stations/39hk-dx4f>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HeadsignRule {
        /// Stop the rule is for.
        #[prost(message, optional, tag = "1")]
        pub stop: ::core::option::Option<Reference>,
        /// Priority of the rule (lower is higher priority).
        #[prost(int32, tag = "2")]
        pub priority: i32,
        /// NYCT track.
        #[prost(string, optional, tag = "3")]
        pub track: ::core::option::Option<::prost::alloc::string::String>,
        /// Headsign for trains arriving on the track.
        #[prost(string, tag = "4")]
        pub headsign: ::prost::alloc::string::String,
    }
    /// Reference type for the stop resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, optional, tag = "4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Enum describing the possible stop types
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Stop = 0,
        Station = 1,
        EntranceOrExit = 2,
        GenericNode = 3,
        BoardingArea = 4,
        Platform = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Stop => "STOP",
                Type::Station => "STATION",
                Type::EntranceOrExit => "ENTRANCE_OR_EXIT",
                Type::GenericNode => "GENERIC_NODE",
                Type::BoardingArea => "BOARDING_AREA",
                Type::Platform => "PLATFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOP" => Some(Self::Stop),
                "STATION" => Some(Self::Station),
                "ENTRANCE_OR_EXIT" => Some(Self::EntranceOrExit),
                "GENERIC_NODE" => Some(Self::GenericNode),
                "BOARDING_AREA" => Some(Self::BoardingArea),
                "PLATFORM" => Some(Self::Platform),
                _ => None,
            }
        }
    }
}
/// Message describing a realtime stop time.
///
/// A stop time is an event in which a trip calls at a stop.
/// This message corresponds to the [GTFS realtime `StopTimeUpdate`
/// message](<https://gtfs.org/realtime/reference/#message-stoptimeupdate>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTime {
    /// The stop.
    #[prost(message, optional, tag = "1")]
    pub stop: ::core::option::Option<stop::Reference>,
    /// The trip.
    #[prost(message, optional, tag = "2")]
    pub trip: ::core::option::Option<trip::Reference>,
    /// The last stop the trip calls at.
    /// Only populated for StopTime messages returned in Stops.
    /// For Trip messages, the destination can be determined from the list of stop times in the message.
    #[prost(message, optional, tag = "9")]
    pub destination: ::core::option::Option<stop::Reference>,
    /// Vehicle corresponding to this trip, if set.
    /// Only populated for StopTime messages returned in Stops.
    /// For Trip messages, the vehicle is contained in the message itself.
    #[prost(message, optional, tag = "10")]
    pub vehicle: ::core::option::Option<vehicle::Reference>,
    /// Arrival time.
    #[prost(message, optional, tag = "3")]
    pub arrival: ::core::option::Option<stop_time::EstimatedTime>,
    /// Departure time.
    #[prost(message, optional, tag = "4")]
    pub departure: ::core::option::Option<stop_time::EstimatedTime>,
    /// If this stop time is in the future.
    /// This field is *not* based on the arrival or departure time.
    /// Instead, a stop time is considered in the future if it appeared in the most recent
    /// GTFS realtime feed for its trip.
    /// When this stop time disappears from the trip, Transiter marks it as in the past and freezes
    /// its data.
    #[prost(bool, tag = "5")]
    pub future: bool,
    /// Stop sequence.
    #[prost(int32, tag = "6")]
    pub stop_sequence: i32,
    /// Headsign.
    #[prost(string, optional, tag = "7")]
    pub headsign: ::core::option::Option<::prost::alloc::string::String>,
    /// Track, from the NYCT realtime extension.
    #[prost(string, optional, tag = "8")]
    pub track: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StopTime`.
pub mod stop_time {
    /// Message describing the arrival or departure time of a stop time.
    /// This corresponds to the [GTFS realtime `StopTimeEvent`
    /// message](<https://gtfs.org/realtime/reference/#message-stoptimeevent>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EstimatedTime {
        /// Time of arrival.
        #[prost(int64, optional, tag = "1")]
        pub time: ::core::option::Option<i64>,
        /// Delay from the scheduled time.
        #[prost(int32, optional, tag = "2")]
        pub delay: ::core::option::Option<i32>,
        /// Measure of the uncertainty of the data in this message.
        #[prost(int32, optional, tag = "3")]
        pub uncertainty: ::core::option::Option<i32>,
    }
}
/// The Trip resource.
///
/// This resource corresponds to the [trip update type in the GTFS static
/// specification](<https://gtfs.org/realtime/reference/#message-tripupdate>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trip {
    /// ID of the trip.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the trip resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// Route corresponding to this trip.
    /// This is the parent resource in Transiter's resource hierarchy.
    /// It is determined using the `route_id` field in the GTFS realtime feed.
    #[prost(message, optional, tag = "3")]
    pub route: ::core::option::Option<route::Reference>,
    /// Time the trip started at.
    #[prost(int64, optional, tag = "4")]
    pub started_at: ::core::option::Option<i64>,
    /// Vehicle corresponding to the trip.
    #[prost(message, optional, tag = "5")]
    pub vehicle: ::core::option::Option<vehicle::Reference>,
    /// Direction ID of the trip.
    #[prost(bool, tag = "6")]
    pub direction_id: bool,
    /// Stop times of the trip.
    #[prost(message, repeated, tag = "7")]
    pub stop_times: ::prost::alloc::vec::Vec<StopTime>,
    /// Shape of the trip.
    #[prost(message, optional, tag = "8")]
    pub shape: ::core::option::Option<shape::Reference>,
    /// Active alerts for this trip.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/feed-entities/service-alerts/#service-alerts>).
    #[prost(message, repeated, tag = "9")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
}
/// Nested message and enum types in `Trip`.
pub mod trip {
    /// Reference type for the trip resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub route: ::core::option::Option<super::route::Reference>,
        /// The last stop this trip calls at.
        /// This field is only populated in trip references in StopTime messages.
        /// It is deprecated in favor of the destination field on the StopTime message itself,
        ///     and will be removed in v2.
        #[deprecated]
        #[prost(message, optional, tag = "4")]
        pub destination: ::core::option::Option<super::stop::Reference>,
        /// Vehicle corresponding to this trip.
        /// This field is only populated in trip references in StopTime messages.
        /// It is deprecated in favor of the destination field on the StopTime message itself,
        ///     and will be removed in v2.
        #[deprecated]
        #[prost(message, optional, tag = "5")]
        pub vehicle: ::core::option::Option<super::vehicle::Reference>,
        /// Same as the parent message.
        #[prost(bool, tag = "6")]
        pub direction_id: bool,
    }
}
/// The Vehicle resource.
///
/// This resource corresponds to the [vehicle position type in the GTFS static
/// specification](<https://gtfs.org/realtime/reference/#message-vehicleposition>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vehicle {
    /// A unique ID for the vehicle.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// A reference to the vehicle's trip.
    #[prost(message, optional, tag = "2")]
    pub trip: ::core::option::Option<trip::Reference>,
    /// The vehicle's current latitude.
    #[prost(double, optional, tag = "3")]
    pub latitude: ::core::option::Option<f64>,
    /// The vehicle's current longitude.
    #[prost(double, optional, tag = "4")]
    pub longitude: ::core::option::Option<f64>,
    /// The vehicle's current bearing.
    #[prost(float, optional, tag = "5")]
    pub bearing: ::core::option::Option<f32>,
    /// The vehicle's current odometer reading.
    #[prost(double, optional, tag = "6")]
    pub odometer: ::core::option::Option<f64>,
    /// The vehicle's current speed.
    #[prost(float, optional, tag = "7")]
    pub speed: ::core::option::Option<f32>,
    /// The stop sequence index of the vehicle's current stop.
    #[prost(int32, optional, tag = "8")]
    pub stop_sequence: ::core::option::Option<i32>,
    /// A reference to the vehicle's current stop.
    #[prost(message, optional, tag = "9")]
    pub stop: ::core::option::Option<stop::Reference>,
    /// The vehicle's current status.
    #[prost(enumeration = "vehicle::CurrentStatus", optional, tag = "10")]
    pub current_status: ::core::option::Option<i32>,
    /// The timestamp of the last update to the vehicle's position.
    #[prost(int64, optional, tag = "11")]
    pub updated_at: ::core::option::Option<i64>,
    /// The vehicle's current congestion level.
    #[prost(enumeration = "vehicle::CongestionLevel", tag = "12")]
    pub congestion_level: i32,
    /// The vehicle's current occupancy status.
    #[prost(enumeration = "vehicle::OccupancyStatus", optional, tag = "13")]
    pub occupancy_status: ::core::option::Option<i32>,
    /// The percentage of seats occupied.
    #[prost(int32, optional, tag = "14")]
    pub occupancy_percentage: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Vehicle`.
pub mod vehicle {
    /// Reference type for the vehicle resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
    /// Corresponds to [VehicleStopStatus](<https://gtfs.org/realtime/reference/#enum-vehiclestopstatus>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrentStatus {
        IncomingAt = 0,
        StoppedAt = 1,
        InTransitTo = 2,
    }
    impl CurrentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CurrentStatus::IncomingAt => "INCOMING_AT",
                CurrentStatus::StoppedAt => "STOPPED_AT",
                CurrentStatus::InTransitTo => "IN_TRANSIT_TO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INCOMING_AT" => Some(Self::IncomingAt),
                "STOPPED_AT" => Some(Self::StoppedAt),
                "IN_TRANSIT_TO" => Some(Self::InTransitTo),
                _ => None,
            }
        }
    }
    /// Corresponds to [CongestionLevel](<https://gtfs.org/realtime/reference/#enum-congestionlevel>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CongestionLevel {
        UnknownCongestionLevel = 0,
        RunningSmoothly = 1,
        StopAndGo = 2,
        Congestion = 3,
        SevereCongestion = 4,
    }
    impl CongestionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CongestionLevel::UnknownCongestionLevel => "UNKNOWN_CONGESTION_LEVEL",
                CongestionLevel::RunningSmoothly => "RUNNING_SMOOTHLY",
                CongestionLevel::StopAndGo => "STOP_AND_GO",
                CongestionLevel::Congestion => "CONGESTION",
                CongestionLevel::SevereCongestion => "SEVERE_CONGESTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CONGESTION_LEVEL" => Some(Self::UnknownCongestionLevel),
                "RUNNING_SMOOTHLY" => Some(Self::RunningSmoothly),
                "STOP_AND_GO" => Some(Self::StopAndGo),
                "CONGESTION" => Some(Self::Congestion),
                "SEVERE_CONGESTION" => Some(Self::SevereCongestion),
                _ => None,
            }
        }
    }
    /// Corresponds to [OccupancyStatus](<https://gtfs.org/realtime/reference/#enum-occupancystatus>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OccupancyStatus {
        Empty = 0,
        ManySeatsAvailable = 1,
        FewSeatsAvailable = 2,
        StandingRoomOnly = 3,
        CrushedStandingRoomOnly = 4,
        Full = 5,
        NotAcceptingPassengers = 6,
    }
    impl OccupancyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OccupancyStatus::Empty => "EMPTY",
                OccupancyStatus::ManySeatsAvailable => "MANY_SEATS_AVAILABLE",
                OccupancyStatus::FewSeatsAvailable => "FEW_SEATS_AVAILABLE",
                OccupancyStatus::StandingRoomOnly => "STANDING_ROOM_ONLY",
                OccupancyStatus::CrushedStandingRoomOnly => "CRUSHED_STANDING_ROOM_ONLY",
                OccupancyStatus::Full => "FULL",
                OccupancyStatus::NotAcceptingPassengers => "NOT_ACCEPTING_PASSENGERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EMPTY" => Some(Self::Empty),
                "MANY_SEATS_AVAILABLE" => Some(Self::ManySeatsAvailable),
                "FEW_SEATS_AVAILABLE" => Some(Self::FewSeatsAvailable),
                "STANDING_ROOM_ONLY" => Some(Self::StandingRoomOnly),
                "CRUSHED_STANDING_ROOM_ONLY" => Some(Self::CrushedStandingRoomOnly),
                "FULL" => Some(Self::Full),
                "NOT_ACCEPTING_PASSENGERS" => Some(Self::NotAcceptingPassengers),
                _ => None,
            }
        }
    }
}
/// The Route resource.
///
/// This resource corresponds to the [route type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#routestxt>).
/// Most of the fields in the resource come directly from the `routes.txt` table.
/// Transiter adds some additional related fields (agency, alerts)
///    and computed fields (estimated headway, service maps).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    /// ID of the route. This is the `route_id` column in `routes.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the route resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this route.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Short name of the route. This is the `route_short_name` column in `routes.txt`.
    #[prost(string, optional, tag = "4")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Long name of the route. This is the `route_long_name` column in `routes.txt`.
    #[prost(string, optional, tag = "5")]
    pub long_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Color of the route. This is the `route_color` column in `routes.txt`.
    #[prost(string, tag = "6")]
    pub color: ::prost::alloc::string::String,
    /// Text color of the route. This is the `route_text_color` column in `routes.txt`.
    #[prost(string, tag = "7")]
    pub text_color: ::prost::alloc::string::String,
    /// Description of the route. This is the `route_desc` column in `routes.txt`.
    #[prost(string, optional, tag = "8")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// URL of a web page about the route. This is the `route_url` column in `routes.txt`.
    #[prost(string, optional, tag = "9")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Sort order of the route. This is the `route_sort_order` column in `routes.txt`.
    #[prost(int32, optional, tag = "10")]
    pub sort_order: ::core::option::Option<i32>,
    /// Continuous pickup policy. This is the `continuous_pickup` column in `routes.txt`.
    #[prost(enumeration = "route::ContinuousPolicy", tag = "11")]
    pub continuous_pickup: i32,
    /// Continuous dropoff policy. This is the `continuous_dropoff` column in `routes.txt`.
    #[prost(enumeration = "route::ContinuousPolicy", tag = "12")]
    pub continuous_drop_off: i32,
    /// Type of the route. This is the `route_type` column in `routes.txt`.
    #[prost(enumeration = "route::Type", tag = "13")]
    pub r#type: i32,
    /// Agency this route is associated to.
    ///
    /// This is determined using the `agency_id` column in `routes.txt`.
    #[prost(message, optional, tag = "14")]
    pub agency: ::core::option::Option<agency::Reference>,
    /// Active alerts for this route.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/feed-entities/service-alerts/#service-alerts>).
    #[prost(message, repeated, tag = "15")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
    /// An estimate of the interval of time between consecutive realtime trips, in seconds.
    ///
    /// If there is insufficient data to compute an estimate, the field will be empty.
    ///
    /// The estimate is computed as follows.
    /// For each stop that has realtime trips for the route,
    ///   the list of arrival times for those trips is examined.
    /// The difference between consecutive arrival times is calculated.
    /// If there are `N` trips, there will be `N-1` such arrival time diffs.
    /// The estimated headway is the average of these diffs across
    /// all stops.
    #[prost(int32, optional, tag = "16")]
    pub estimated_headway: ::core::option::Option<i32>,
    /// List of service maps for this route.
    #[prost(message, repeated, tag = "17")]
    pub service_maps: ::prost::alloc::vec::Vec<route::ServiceMap>,
}
/// Nested message and enum types in `Route`.
pub mod route {
    /// Message describing the service maps view in routes.
    ///
    /// See the [service maps documentation](../systems.md#service-maps) for more information on this
    /// message and the associated field.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceMap {
        /// Config ID of the service map, as specified in the system configuration file.
        #[prost(string, tag = "1")]
        pub config_id: ::prost::alloc::string::String,
        /// Ordered list of stops at which this route calls.
        ///
        /// This list may be empty, in which case the route has no service in the service map.
        #[prost(message, repeated, tag = "2")]
        pub stops: ::prost::alloc::vec::Vec<super::stop::Reference>,
    }
    /// Reference type for the route resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, tag = "4")]
        pub color: ::prost::alloc::string::String,
    }
    /// Enum describing possible policies for continuous pickup or drop-off.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContinuousPolicy {
        /// Continuous pickup or drop-off allowed.
        Allowed = 0,
        /// Continuous pickup or drop-off not allowed.
        NotAllowed = 1,
        /// Must phone the agency to arrange continuous pickup or drop-off.
        PhoneAgency = 2,
        /// Must coordinate with driver to arrange continuous pickup or drop-off.
        CoordinateWithDriver = 3,
    }
    impl ContinuousPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContinuousPolicy::Allowed => "ALLOWED",
                ContinuousPolicy::NotAllowed => "NOT_ALLOWED",
                ContinuousPolicy::PhoneAgency => "PHONE_AGENCY",
                ContinuousPolicy::CoordinateWithDriver => "COORDINATE_WITH_DRIVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALLOWED" => Some(Self::Allowed),
                "NOT_ALLOWED" => Some(Self::NotAllowed),
                "PHONE_AGENCY" => Some(Self::PhoneAgency),
                "COORDINATE_WITH_DRIVER" => Some(Self::CoordinateWithDriver),
                _ => None,
            }
        }
    }
    /// Enum describing possible route types.
    /// This corresponds to possible values of the `route_type` column in `routes.txt`.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        LightRail = 0,
        Subway = 1,
        Rail = 2,
        Bus = 3,
        Ferry = 4,
        CableTram = 5,
        AerialLift = 6,
        Funicular = 7,
        TrolleyBus = 11,
        Monorail = 12,
        Unknown = 100,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::LightRail => "LIGHT_RAIL",
                Type::Subway => "SUBWAY",
                Type::Rail => "RAIL",
                Type::Bus => "BUS",
                Type::Ferry => "FERRY",
                Type::CableTram => "CABLE_TRAM",
                Type::AerialLift => "AERIAL_LIFT",
                Type::Funicular => "FUNICULAR",
                Type::TrolleyBus => "TROLLEY_BUS",
                Type::Monorail => "MONORAIL",
                Type::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIGHT_RAIL" => Some(Self::LightRail),
                "SUBWAY" => Some(Self::Subway),
                "RAIL" => Some(Self::Rail),
                "BUS" => Some(Self::Bus),
                "FERRY" => Some(Self::Ferry),
                "CABLE_TRAM" => Some(Self::CableTram),
                "AERIAL_LIFT" => Some(Self::AerialLift),
                "FUNICULAR" => Some(Self::Funicular),
                "TROLLEY_BUS" => Some(Self::TrolleyBus),
                "MONORAIL" => Some(Self::Monorail),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// The feed resource.
///
/// Each feed is defined in the system configuration file.
/// Feeds are included in the public API because there are non-admin use-cases for this resource.
/// For example, an app might publish the staleness of realtime data
///    by checking the last successful feed update time.
///
/// More detailed information on a feed -- its full configuration, and the
///    current status of its periodic updates -- can be retrieved through the
///    [admin API's GetSystemConfig endpoint](admin.md#get-the-config-for-a-system).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Feed {
    /// ID of the feed, as specified in the system configuration file.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the feed resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this feed.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Unix milliseconds timestamp of when the last update of this feed finished.
    /// There are three outcomes for each update:
    ///     successful (new data is retrieved from the transit agency and persisted),
    ///     skipped (the transit agency returned the same data as the last update, so there is nothing to do),
    ///     and failed (something went wrong, e.g. the transit agency's feed is unavailable).
    #[prost(int64, optional, tag = "4")]
    pub last_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last successful update of this feed finished.
    #[prost(int64, optional, tag = "5")]
    pub last_successful_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last skipped update of this feed finished.
    #[prost(int64, optional, tag = "6")]
    pub last_skipped_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last failed update of this feed finished.
    #[prost(int64, optional, tag = "7")]
    pub last_failed_update_ms: ::core::option::Option<i64>,
}
/// Nested message and enum types in `Feed`.
pub mod feed {
    /// Reference type for the feed resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
    }
}
/// The Agency resource.
///
/// This resource corresponds to the [`agency.txt` table in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#agencytxt>).
/// Most of the fields in the resource come directly from the `agency.txt` table.
/// Transiter adds some additional related fields (routes, alerts).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Agency {
    /// ID of the agency. This is the `agency_id` column in `agency.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the agency resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this agency.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Name of the agency. This is the `agency_name` column in `agency.txt`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// URL of the agency. This is the `agency_url` column in `agency.txt`.
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    /// Timezone of the agency. This is the `agency_timezone` column in `agency.txt`.
    #[prost(string, tag = "6")]
    pub timezone: ::prost::alloc::string::String,
    /// Language of the agency. This is the `agency_lang` column in `agency.txt`.
    #[prost(string, optional, tag = "7")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// Phone number of the agency. This is the `agency_phone` column in `agency.txt`.
    #[prost(string, optional, tag = "8")]
    pub phone: ::core::option::Option<::prost::alloc::string::String>,
    /// URL where tickets for the agency's services ban be bought.
    /// This is the `agency_fare_url` column in `agency.txt`.
    #[prost(string, optional, tag = "9")]
    pub fare_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the agency. This is the `agency_email` column in `agency.txt`.
    #[prost(string, optional, tag = "10")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// List of routes operating under this agency.
    ///
    /// These are determined using the `agency_id` column in `routes.txt`.
    #[prost(message, repeated, tag = "11")]
    pub routes: ::prost::alloc::vec::Vec<route::Reference>,
    /// List of active alerts for the agency.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/reference/#message-alert>).
    #[prost(message, repeated, tag = "12")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
}
/// Nested message and enum types in `Agency`.
pub mod agency {
    /// Reference type for the agency resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, tag = "4")]
        pub name: ::prost::alloc::string::String,
    }
}
/// The Alert resource.
///
/// This resource corresponds to the [alert message in the GTFS realtime
/// specification](<https://gtfs.org/realtime/reference/#message-alert>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alert {
    /// ID of the alert. This corresponds to the [ID field in the feed entity
    /// message](<https://gtfs.org/realtime/reference/#message-feedentity>)
    /// corresponding to the alert.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the alert resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this alert.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Cause of the alert. This corresponds to the `cause` field in the realtime alert message.
    #[prost(enumeration = "alert::Cause", tag = "4")]
    pub cause: i32,
    /// Effect of the alert. This corresponds to the `effect` field in the realtime alert message.
    #[prost(enumeration = "alert::Effect", tag = "5")]
    pub effect: i32,
    /// The current active period, if the alert is currently active.
    /// If the alert is not active this is empty.
    #[prost(message, optional, tag = "6")]
    pub current_active_period: ::core::option::Option<alert::ActivePeriod>,
    /// All active periods for this alert.
    /// Transiter guarantees that these active periods have no overlap.
    #[prost(message, repeated, tag = "7")]
    pub all_active_periods: ::prost::alloc::vec::Vec<alert::ActivePeriod>,
    /// Header of the alert, in zero or more languages.
    /// This corresponds to the `header_text` field in the realtime alert message.
    #[prost(message, repeated, tag = "8")]
    pub header: ::prost::alloc::vec::Vec<alert::Text>,
    /// Description of the alert, in zero or more languages.
    /// This corresponds to the `description_text` field in the realtime alert message.
    #[prost(message, repeated, tag = "9")]
    pub description: ::prost::alloc::vec::Vec<alert::Text>,
    /// URL for additional information about the alert, in zero or more languages.
    /// This corresponds to the `url` field in the realtime alert message.
    #[prost(message, repeated, tag = "10")]
    pub url: ::prost::alloc::vec::Vec<alert::Text>,
}
/// Nested message and enum types in `Alert`.
pub mod alert {
    /// The active period message describes a period when an alert is active.
    /// It corresponds the the [time range message in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#message-timerange>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActivePeriod {
        /// Unix timestamp of the start time of the active period.
        /// If not set, the alert be interpreted
        /// as being always active up to the end time.
        #[prost(int64, optional, tag = "1")]
        pub starts_at: ::core::option::Option<i64>,
        /// Unix timestamp of the end time of the active period.
        /// If not set, the alert be interpreted as being indefinitely active.
        #[prost(int64, optional, tag = "2")]
        pub ends_at: ::core::option::Option<i64>,
    }
    /// The text message describes an alert header/description/URL in a specified language.
    /// It corresponds the the [translation message in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#message-translation>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        /// Content of the text.
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        /// Language of this text.
        #[prost(string, tag = "2")]
        pub language: ::prost::alloc::string::String,
    }
    /// Reference type for the agency resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(enumeration = "Cause", tag = "4")]
        pub cause: i32,
        /// Same as the parent message.
        #[prost(enumeration = "Effect", tag = "5")]
        pub effect: i32,
    }
    /// Cause is the same as the [cause enum in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#enum-cause>),
    /// except `UNKNOWN_CAUSE` has value 0 instead of 1 to satisfy protobuf3 requirements.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cause {
        UnknownCause = 0,
        OtherCause = 2,
        TechnicalProblem = 3,
        Strike = 4,
        Demonstration = 5,
        Accident = 6,
        Holiday = 7,
        Weather = 8,
        Maintenance = 9,
        Construction = 10,
        PoliceActivity = 11,
        MedicalEmergency = 12,
    }
    impl Cause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Cause::UnknownCause => "UNKNOWN_CAUSE",
                Cause::OtherCause => "OTHER_CAUSE",
                Cause::TechnicalProblem => "TECHNICAL_PROBLEM",
                Cause::Strike => "STRIKE",
                Cause::Demonstration => "DEMONSTRATION",
                Cause::Accident => "ACCIDENT",
                Cause::Holiday => "HOLIDAY",
                Cause::Weather => "WEATHER",
                Cause::Maintenance => "MAINTENANCE",
                Cause::Construction => "CONSTRUCTION",
                Cause::PoliceActivity => "POLICE_ACTIVITY",
                Cause::MedicalEmergency => "MEDICAL_EMERGENCY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CAUSE" => Some(Self::UnknownCause),
                "OTHER_CAUSE" => Some(Self::OtherCause),
                "TECHNICAL_PROBLEM" => Some(Self::TechnicalProblem),
                "STRIKE" => Some(Self::Strike),
                "DEMONSTRATION" => Some(Self::Demonstration),
                "ACCIDENT" => Some(Self::Accident),
                "HOLIDAY" => Some(Self::Holiday),
                "WEATHER" => Some(Self::Weather),
                "MAINTENANCE" => Some(Self::Maintenance),
                "CONSTRUCTION" => Some(Self::Construction),
                "POLICE_ACTIVITY" => Some(Self::PoliceActivity),
                "MEDICAL_EMERGENCY" => Some(Self::MedicalEmergency),
                _ => None,
            }
        }
    }
    /// Effect is the same as the [effect enum in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#enum-effect>),
    /// except `UNKNOWN_EFFECT` has value 0 instead of 1 to satisfy protobuf3 requirements.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Effect {
        UnknownEffect = 0,
        NoService = 1,
        ReducedService = 2,
        SignificantDelays = 3,
        Detour = 4,
        AdditionalService = 5,
        ModifiedService = 6,
        OtherEffect = 7,
        StopMoved = 9,
        NoEffect = 10,
        AccessibilityIssue = 11,
    }
    impl Effect {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Effect::UnknownEffect => "UNKNOWN_EFFECT",
                Effect::NoService => "NO_SERVICE",
                Effect::ReducedService => "REDUCED_SERVICE",
                Effect::SignificantDelays => "SIGNIFICANT_DELAYS",
                Effect::Detour => "DETOUR",
                Effect::AdditionalService => "ADDITIONAL_SERVICE",
                Effect::ModifiedService => "MODIFIED_SERVICE",
                Effect::OtherEffect => "OTHER_EFFECT",
                Effect::StopMoved => "STOP_MOVED",
                Effect::NoEffect => "NO_EFFECT",
                Effect::AccessibilityIssue => "ACCESSIBILITY_ISSUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_EFFECT" => Some(Self::UnknownEffect),
                "NO_SERVICE" => Some(Self::NoService),
                "REDUCED_SERVICE" => Some(Self::ReducedService),
                "SIGNIFICANT_DELAYS" => Some(Self::SignificantDelays),
                "DETOUR" => Some(Self::Detour),
                "ADDITIONAL_SERVICE" => Some(Self::AdditionalService),
                "MODIFIED_SERVICE" => Some(Self::ModifiedService),
                "OTHER_EFFECT" => Some(Self::OtherEffect),
                "STOP_MOVED" => Some(Self::StopMoved),
                "NO_EFFECT" => Some(Self::NoEffect),
                "ACCESSIBILITY_ISSUE" => Some(Self::AccessibilityIssue),
                _ => None,
            }
        }
    }
}
/// The Transfer resource.
///
/// This resource corresponds to the [transfer table in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#transferstxt>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transfer {
    /// Unique ID for the transfer.
    /// This is generated by Transiter because in the GTFS static spec transfers do not have IDs.
    #[prost(string, tag = "9")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the transfer resource.
    #[prost(message, optional, tag = "10")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this transfer.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "11")]
    pub system: ::core::option::Option<system::Reference>,
    /// Beginning stop of the transfer. This is determined using the `from_stop_id` column in `transfers.txt`.
    #[prost(message, optional, tag = "4")]
    pub from_stop: ::core::option::Option<stop::Reference>,
    /// Ending stop of the transfer. This is determined using the `to_stop_id` column in `transfers.txt`.
    #[prost(message, optional, tag = "5")]
    pub to_stop: ::core::option::Option<stop::Reference>,
    /// Type of the transfer.
    #[prost(enumeration = "transfer::Type", tag = "6")]
    pub r#type: i32,
    /// Minimum time required for the transfer, in seconds. This is the `min_transfer_time` column in `transfers.txt`.
    #[prost(int32, optional, tag = "7")]
    pub min_transfer_time: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Transfer`.
pub mod transfer {
    /// Types of transfers.
    /// The supported types are described in the documentation for the `transfer_type` column
    /// in the GTFS static `transfers.txt` table.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Recommended = 0,
        Timed = 1,
        RequiresTime = 2,
        NotPossible = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Recommended => "RECOMMENDED",
                Type::Timed => "TIMED",
                Type::RequiresTime => "REQUIRES_TIME",
                Type::NotPossible => "NOT_POSSIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECOMMENDED" => Some(Self::Recommended),
                "TIMED" => Some(Self::Timed),
                "REQUIRES_TIME" => Some(Self::RequiresTime),
                "NOT_POSSIBLE" => Some(Self::NotPossible),
                _ => None,
            }
        }
    }
}
/// The Shape resource.
///
/// This resource corresponds to the [shape type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#shapestxt>).
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shape {
    /// Unique ID for the shape.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Ordered list of points that make up the shape.
    #[prost(message, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<shape::ShapePoint>,
}
/// Nested message and enum types in `Shape`.
pub mod shape {
    /// A point within the shape.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ShapePoint {
        /// Latitude of the point.
        #[prost(double, tag = "1")]
        pub latitude: f64,
        /// Longitude of the point.
        #[prost(double, tag = "2")]
        pub longitude: f64,
        /// Distance from the start of the shape to this point.
        #[prost(double, optional, tag = "3")]
        pub distance: ::core::option::Option<f64>,
    }
    /// Reference type for the shape resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
}
/// Request payload for the get system config endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemConfigRequest {
    /// ID of the system whose config is to be retrieved.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Request payload for the install or update system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallOrUpdateSystemRequest {
    /// ID of the system to install or update.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If true, do not perform an update if the system already exists.
    #[prost(bool, tag = "4")]
    pub install_only: bool,
    #[prost(oneof = "install_or_update_system_request::Config", tags = "2, 3")]
    pub config: ::core::option::Option<install_or_update_system_request::Config>,
}
/// Nested message and enum types in `InstallOrUpdateSystemRequest`.
pub mod install_or_update_system_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Config for the system, in the form or a protobuf message.
        #[prost(message, tag = "2")]
        SystemConfig(super::SystemConfig),
        /// Config for the system, in the form of a YAML file.
        #[prost(message, tag = "3")]
        YamlConfig(super::YamlConfig),
    }
}
/// YamlConfig contains a Transiter system configuration in YAML format.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YamlConfig {
    /// The YAML content.
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    /// Whether the config is a template. If true the config will first be processed
    /// using Go's template library.
    #[prost(bool, tag = "3")]
    pub is_template: bool,
    /// Arguments to pass to Go's template library if the config is a template.
    ///
    /// In general as much information as possible should be in the config itself.
    /// The template args are intended for things like API keys which are secret
    /// and/or different for each person that installs the system.
    #[prost(btree_map = "string, string", tag = "4")]
    pub template_args: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Response payload for the install of update system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallOrUpdateSystemReply {
    /// ID of the system that was installed.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// System configuration that was used for the install.
    /// If the configuration was provided as a YAML file or a YAML template,
    /// the value here represents the fully parsed and expanded configuration.
    #[prost(message, optional, tag = "2")]
    pub system_config: ::core::option::Option<SystemConfig>,
}
/// Request payload for the delete system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSystemRequest {
    /// ID of the system to delete.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the delete system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSystemReply {}
/// Configuration for a system.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemConfig {
    /// Name of the system.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Configuration for the system's feeds.
    #[prost(message, repeated, tag = "2")]
    pub feeds: ::prost::alloc::vec::Vec<FeedConfig>,
    /// Configuration for the system's service maps.
    #[prost(message, repeated, tag = "3")]
    pub service_maps: ::prost::alloc::vec::Vec<ServiceMapConfig>,
}
/// Configuration for a transit system data feed.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedConfig {
    /// Identifier of this feed config.
    /// This must be unique within the system.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The type of the feed.
    /// Allowable values are `GTFS_STATIC`, `GTFS_REALTIME` and `NYCT_SUBWAY_CSV`.
    ///
    /// The are possible future plans to support plugging in additional custom types at build time.
    /// This is why the field is a string and not an enum.
    #[prost(string, tag = "13")]
    pub r#type: ::prost::alloc::string::String,
    /// Deprecated: use `type` instead.
    #[deprecated]
    #[prost(string, tag = "8")]
    pub parser: ::prost::alloc::string::String,
    /// Additional options GTFS realtime feeds.
    #[prost(message, optional, tag = "9")]
    pub gtfs_realtime_options: ::core::option::Option<GtfsRealtimeOptions>,
    /// Required for install specifies whether an update should be performed for this feed during system install.
    /// If true, an update is performed and if the update fails the installation fails.
    ///
    /// If unspecified, defaults to false for GTFS realtime feeds and true for all other
    /// types of feeds.
    #[prost(bool, optional, tag = "2")]
    pub required_for_install: ::core::option::Option<bool>,
    /// The scheduling policy to use for this feed.
    ///
    /// If unspecified, it takes the value `DEFAULT``.
    #[prost(enumeration = "feed_config::SchedulingPolicy", tag = "14")]
    pub scheduling_policy: i32,
    /// Deprecated: use `scheduling_policy` instead.
    #[deprecated]
    #[prost(enumeration = "feed_config::SchedulingPolicy", tag = "3")]
    pub update_strategy: i32,
    /// For feeds with a `PERIODIC` scheduling policy, the update period.
    ///
    /// If unspecified, defaults to 5 seconds.
    #[prost(int64, optional, tag = "10")]
    pub periodic_update_period_ms: ::core::option::Option<i64>,
    /// Deprecated: use `periodic_update_period_ms` instead.
    #[deprecated]
    #[prost(double, optional, tag = "4")]
    pub update_period_s: ::core::option::Option<f64>,
    /// For feeds with a `DAILY` scheduling policy,
    /// the time of day in the form HH:MM at which to perform an update.
    ///
    /// If unspecified, defaults to 03:00 for the first feed in the system, 03:10 for the second feed,
    /// and so on.
    /// The idea of the default is to run at night when the system is either quiet or not running.
    /// The staggering is to avoid updates stepping on each other, and to spread out the load.
    #[prost(string, tag = "11")]
    pub daily_update_time: ::prost::alloc::string::String,
    /// For feeds with a `DAILY` scheduling policy,
    /// the timezone for the time of day specified in the `daily_update_time`.
    ///
    /// If empty, a default is provided as follows.
    /// The scheduler lists the agencies for the system in order of ID and uses
    /// the first valid timezone it finds.
    /// Given the GTFS static specification this should always work.
    /// Moreover, all agencies should have the same timezone so listing in order of ID shouldn't matter.
    /// But in reality it may not work.
    /// If there is no valid agency timezones, the scheduler will log a warning and fall back to UTC.
    #[prost(string, tag = "12")]
    pub daily_update_timezone: ::prost::alloc::string::String,
    /// URL at which the feed can be downloaded using a HTTP GET request.
    /// Transiter does not currently support non-GET requests.
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    /// Timeout to enforce for the request to the feed URL. If not specified, defaults to 5 seconds.
    #[prost(int64, optional, tag = "6")]
    pub request_timeout_ms: ::core::option::Option<i64>,
    /// HTTP headers to send in the request.
    #[prost(btree_map = "string, string", tag = "7")]
    pub http_headers: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Additional options for NYCT Subway feeds.
    #[prost(message, optional, tag = "15")]
    pub nyct_subway_options: ::core::option::Option<feed_config::NyctSubwayOptions>,
}
/// Nested message and enum types in `FeedConfig`.
pub mod feed_config {
    /// Additional options for NYCT Subway CSV feeds.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctSubwayOptions {
        /// If true, infer the 'wheelchair_boarding' field from this feed.
        ///
        /// Historically, this information is not set in the NYC Subway GTFS feed, but
        /// is included in the extended NYCT_SUBWAY_CSV feed.
        ///
        /// To use the data from the CSV feed, set thie field to true on that feed and
        /// false on the GTFS static feed. If this field is not set on either feed,
        /// the GTFS static feed will be used.
        ///
        /// Avoid setting this field to true on both feeds, as this will result in
        /// non-deterministic behavior, since feed updates are not guaranteed to be ordered
        /// after initial system installation.
        #[prost(bool, tag = "1")]
        pub use_accessibility_info: bool,
    }
    /// Transiter runs a background task called the scheduler which performs feed updates automatically.
    /// A scheduling policy determines when the scheduler will perform feed updates for this feed.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchedulingPolicy {
        /// Use the default policy, which is PERIODIC for GTFS realtime feeds and DAILY for all other feeds.
        Default = 0,
        /// Perform an update periodically, with the period specified in the `periodic_update_period_ms` field.
        Periodic = 1,
        /// Perform an update once a day, with the time of day specified in the `daily_update_time` field.
        Daily = 2,
        /// Don't perform updates in the scheduler. Updates can always be triggered manually using the admin API.
        None = 3,
    }
    impl SchedulingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SchedulingPolicy::Default => "DEFAULT",
                SchedulingPolicy::Periodic => "PERIODIC",
                SchedulingPolicy::Daily => "DAILY",
                SchedulingPolicy::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "PERIODIC" => Some(Self::Periodic),
                "DAILY" => Some(Self::Daily),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Message describing additional options for the GTFS realtime feeds.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GtfsRealtimeOptions {
    /// GTFS realtime extension to use.
    #[prost(enumeration = "gtfs_realtime_options::Extension", tag = "1")]
    pub extension: i32,
    /// Options for the NYCT trips extension.
    /// Ignored if the extension field is not `NYCT_TRIPS`.
    #[prost(message, optional, tag = "2")]
    pub nyct_trips_options: ::core::option::Option<
        gtfs_realtime_options::NyctTripsOptions,
    >,
    /// Options for the NYCT alerts extension.
    /// Ignored if the extension field is not `NYCT_ALERTS`.
    #[prost(message, optional, tag = "3")]
    pub nyct_alerts_options: ::core::option::Option<
        gtfs_realtime_options::NyctAlertsOptions,
    >,
    /// If true, stop sequences in the GTFS realtime feed data are ignored, and
    /// alternative stop sequences are generated and assigned by Transiter.
    /// This setting is designed for buggy GTFS realtime feeds in which
    /// stop sequences (incorrectly) change between updates. In many cases
    /// Transiter is able to generate stop sequences that are correct and
    /// stable across updates.
    ///
    /// This should not be used for systems where a trip can call at the same
    /// stop multiple times.
    #[prost(bool, tag = "4")]
    pub reassign_stop_sequences: bool,
}
/// Nested message and enum types in `GtfsRealtimeOptions`.
pub mod gtfs_realtime_options {
    /// Options for the NYCT trips extension.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctTripsOptions {
        /// Filter out trips which are scheduled to run in the past but have no assigned trip and haven't started.
        #[prost(bool, tag = "1")]
        pub filter_stale_unassigned_trips: bool,
        /// The raw MTA data has a bug in which the M train platforms are reported incorrectly for stations
        /// in Williamsburg and Bushwick that the M shares with the J train. In the raw data, M trains going towards
        /// the Williamsburg bridge stop at M11N, but J trains going towards the bridge stop at M11S. By default
        /// this extension fixes these platforms for the M train, so M11N becomes M11S. This fix can be disabled
        /// by setting this option to true.
        #[prost(bool, tag = "2")]
        pub preserve_m_train_platforms_in_bushwick: bool,
    }
    /// Options for the NYCT alerts extension.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctAlertsOptions {
        /// Deduplication policy for elevator alerts.
        #[prost(
            enumeration = "nyct_alerts_options::ElevatorAlertsDeduplicationPolicy",
            tag = "1"
        )]
        pub elevator_alerts_deduplication_policy: i32,
        /// If true, the stop IDs in alerts will always be converted to point to stations.
        /// E.g., if the alert is for the stop F20N (northbound F platform at Bergen St.)
        /// it will be transformed to be for stop F20 (Bergen St. station).
        #[prost(bool, tag = "2")]
        pub elevator_alerts_inform_using_station_ids: bool,
        /// When there are no trains running for a route due to the standard timetable (e.g., there are no C trains
        /// overnight), the MTA publishes an alert. Arguably this is not really an alert because this information is
        /// already in the timetable.
        /// If true, these alerts are skipped.
        #[prost(bool, tag = "3")]
        pub skip_timetabled_no_service_alerts: bool,
        /// The NYCT alerts extension contains many fields like "time alert created at" that don't map to fields in
        /// the standard GTFS realtime protobuf. If true, these fields are put in a json blob and included as an
        /// alert description.
        #[prost(bool, tag = "4")]
        pub add_nyct_metadata: bool,
    }
    /// Nested message and enum types in `NyctAlertsOptions`.
    pub mod nyct_alerts_options {
        /// Available deduplication policies for elevator alerts.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ElevatorAlertsDeduplicationPolicy {
            NoDeduplication = 0,
            DeduplicateInStation = 1,
            DeduplicateInComplex = 2,
        }
        impl ElevatorAlertsDeduplicationPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ElevatorAlertsDeduplicationPolicy::NoDeduplication => {
                        "NO_DEDUPLICATION"
                    }
                    ElevatorAlertsDeduplicationPolicy::DeduplicateInStation => {
                        "DEDUPLICATE_IN_STATION"
                    }
                    ElevatorAlertsDeduplicationPolicy::DeduplicateInComplex => {
                        "DEDUPLICATE_IN_COMPLEX"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_DEDUPLICATION" => Some(Self::NoDeduplication),
                    "DEDUPLICATE_IN_STATION" => Some(Self::DeduplicateInStation),
                    "DEDUPLICATE_IN_COMPLEX" => Some(Self::DeduplicateInComplex),
                    _ => None,
                }
            }
        }
    }
    /// Supported GTFS realtime extensions.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Extension {
        NoExtension = 0,
        NyctTrips = 1,
        NyctAlerts = 2,
    }
    impl Extension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Extension::NoExtension => "NO_EXTENSION",
                Extension::NyctTrips => "NYCT_TRIPS",
                Extension::NyctAlerts => "NYCT_ALERTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_EXTENSION" => Some(Self::NoExtension),
                "NYCT_TRIPS" => Some(Self::NyctTrips),
                "NYCT_ALERTS" => Some(Self::NyctAlerts),
                _ => None,
            }
        }
    }
}
/// Description of the configuration for a collection of service maps.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceMapConfig {
    /// Identifier of this service maps config.
    /// This must be unique within the system.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Source of the service maps built using this config.
    #[prost(enumeration = "service_map_config::Source", tag = "2")]
    pub source: i32,
    /// The threshold setting is used to exclude one-off trip schedules from service maps.
    /// When calculating a service map, all trips are bucketed based on their schedule.
    /// If the threshold is 0.2, trips are only included if the corresponding bucket contains
    /// at least 20% of the trips. In particular, a one-off trip whose bucket only contains
    /// itself will be excluded if there are many other trips.
    ///
    /// Note that a trip's schedule is reversed if needed based on the direction ID.
    #[prost(double, tag = "3")]
    pub threshold: f64,
    /// Additional options relevant for static service maps only.
    #[prost(message, optional, tag = "4")]
    pub static_options: ::core::option::Option<service_map_config::StaticOptions>,
}
/// Nested message and enum types in `ServiceMapConfig`.
pub mod service_map_config {
    /// Description of options relevant for static service maps only.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticOptions {
        /// If specified, only include trips that start earlier than this time.
        /// The time is specified as a number of hours after midnight; i.e., 2:30am is '2.5'.
        #[prost(double, optional, tag = "1")]
        pub starts_earlier_than: ::core::option::Option<f64>,
        /// If specified, only include trips that start later than this time.
        #[prost(double, optional, tag = "2")]
        pub starts_later_than: ::core::option::Option<f64>,
        /// If specified, only include trips that end earlier than this time.
        #[prost(double, optional, tag = "3")]
        pub ends_earlier_than: ::core::option::Option<f64>,
        /// If specified, only include trips that end later than this time.
        #[prost(double, optional, tag = "4")]
        pub ends_later_than: ::core::option::Option<f64>,
        /// If specified, only include trips which run on at least one of the provided days.
        /// If left empty, no trip filtering is provided.
        #[prost(string, repeated, tag = "5")]
        pub days: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Source describes the possible sources for service maps.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        /// Build the service maps using the GTFS static data.
        Static = 0,
        /// Build the service maps using the GTFS realtime data.
        Realtime = 1,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Static => "STATIC",
                Source::Realtime => "REALTIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATIC" => Some(Self::Static),
                "REALTIME" => Some(Self::Realtime),
                _ => None,
            }
        }
    }
}
/// Request payload for the update feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeedRequest {
    /// ID of the system containing the feed to update.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the feed to update.
    #[prost(string, tag = "2")]
    pub feed_id: ::prost::alloc::string::String,
    /// If true, a full feed update will be performed even if the downloaded data is identical
    /// to the last update for this feed.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// Description of a feed update operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedUpdate {
    /// ID of the feed update. This is a randomly generated UUID.
    /// It can be used to find server logs for the update operation.
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The feed configuration that was used to perform the feed update.
    #[prost(message, optional, tag = "27")]
    pub feed_config: ::core::option::Option<FeedConfig>,
    /// Unix timestamp of when the update started.
    #[prost(int64, tag = "4")]
    pub started_at_ms: i64,
    /// Unix timestamp of when the update finished.
    /// Only populated if the update is finished.
    #[prost(int64, optional, tag = "6")]
    pub finished_at_ms: ::core::option::Option<i64>,
    /// Total latency of the feed update, in milliseconds.
    #[prost(int64, optional, tag = "20")]
    pub total_latency_ms: ::core::option::Option<i64>,
    /// Latency of the HTTP request, in milliseconds.
    #[prost(int64, optional, tag = "21")]
    pub download_latency_ms: ::core::option::Option<i64>,
    /// Latency of parsing the downloaded data, in milliseconds.
    #[prost(int64, optional, tag = "22")]
    pub parse_latency_ms: ::core::option::Option<i64>,
    /// Latency of updating the database with the parsed data, in milliseconds.
    #[prost(int64, optional, tag = "25")]
    pub database_latency_ms: ::core::option::Option<i64>,
    /// Status code returned by the HTTP request.
    #[prost(int32, optional, tag = "26")]
    pub download_http_status_code: ::core::option::Option<i32>,
    /// Status of the update.
    #[prost(enumeration = "feed_update::Status", tag = "7")]
    pub status: i32,
    /// Number of bytes in the downloaded feed data.
    /// Only populated if the update successfully downloaded data.
    #[prost(int32, optional, tag = "8")]
    pub content_length: ::core::option::Option<i32>,
    /// Hash of the downloaded feed data. This is used to skip updates
    /// if the feed data hasn't changed.
    /// Only populated if the update successfully downloaded data.
    #[prost(string, optional, tag = "9")]
    pub content_hash: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message of the update.
    /// Only populated if the update finished in an error
    #[prost(string, optional, tag = "10")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FeedUpdate`.
pub mod feed_update {
    /// Status of a feed update.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Unknown status.
        Unknown = 0,
        /// Feed update is in progress. Currently this status never appears in the admin API, but is
        /// added in case Transiter support async feed updates in the future.
        Running = 1,
        /// Finished successfully.
        Updated = 2,
        /// The update was skipped because the downloaded data was identical to the data for the last successful update.
        Skipped = 3,
        /// Failed to download feed data.
        FailedDownloadError = 4,
        /// Feed data was empty.
        FailedEmptyFeed = 5,
        /// The feed configuration is invalid. This typically indicates a bug in Transiter because
        /// the feed configuration is validated when the system is being installed.
        FailedInvalidFeedConfig = 6,
        /// Failed to parse the feed data.
        /// This means the feed data was corrupted or otherwise invalid.
        FailedParseError = 8,
        /// Failed to update the database using the new feed data.
        /// This typically indicates a bug in Transiter or a transient error connecting to the database.
        FailedUpdateError = 9,
        /// An internal unspecified error occurred.
        FailedInternalError = 10,
        /// The feed has an unknown type.
        FailedUnknownFeedType = 11,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unknown => "UNKNOWN",
                Status::Running => "RUNNING",
                Status::Updated => "UPDATED",
                Status::Skipped => "SKIPPED",
                Status::FailedDownloadError => "FAILED_DOWNLOAD_ERROR",
                Status::FailedEmptyFeed => "FAILED_EMPTY_FEED",
                Status::FailedInvalidFeedConfig => "FAILED_INVALID_FEED_CONFIG",
                Status::FailedParseError => "FAILED_PARSE_ERROR",
                Status::FailedUpdateError => "FAILED_UPDATE_ERROR",
                Status::FailedInternalError => "FAILED_INTERNAL_ERROR",
                Status::FailedUnknownFeedType => "FAILED_UNKNOWN_FEED_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "RUNNING" => Some(Self::Running),
                "UPDATED" => Some(Self::Updated),
                "SKIPPED" => Some(Self::Skipped),
                "FAILED_DOWNLOAD_ERROR" => Some(Self::FailedDownloadError),
                "FAILED_EMPTY_FEED" => Some(Self::FailedEmptyFeed),
                "FAILED_INVALID_FEED_CONFIG" => Some(Self::FailedInvalidFeedConfig),
                "FAILED_PARSE_ERROR" => Some(Self::FailedParseError),
                "FAILED_UPDATE_ERROR" => Some(Self::FailedUpdateError),
                "FAILED_INTERNAL_ERROR" => Some(Self::FailedInternalError),
                "FAILED_UNKNOWN_FEED_TYPE" => Some(Self::FailedUnknownFeedType),
                _ => None,
            }
        }
    }
}
/// Response payload for the update feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeedReply {
    /// Information about the feed update that was performed.
    #[prost(message, optional, tag = "1")]
    pub feed_update: ::core::option::Option<FeedUpdate>,
}
/// Request payload for the get scheduler status endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulerStatusRequest {}
/// Response payload for the get scheduler status endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulerStatusReply {
    /// Status for all feeds being updated by the scheduler.
    #[prost(message, repeated, tag = "1")]
    pub feeds: ::prost::alloc::vec::Vec<get_scheduler_status_reply::FeedStatus>,
}
/// Nested message and enum types in `GetSchedulerStatusReply`.
pub mod get_scheduler_status_reply {
    /// Description of the status of one feed.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeedStatus {
        /// ID of the system this feed belongs to.
        #[prost(string, tag = "1")]
        pub system_id: ::prost::alloc::string::String,
        /// Configuration of the feed as used by the scheduler.
        /// If Postgres is manually updated to change the feed configuration,
        /// this may be different what's in Postgres.
        /// The scheduler needs to be updated in this case.
        /// In general, however, the feed config here will match what's in Postgres.
        #[prost(message, optional, tag = "7")]
        pub feed_config: ::core::option::Option<super::FeedConfig>,
        /// Unix timestamp of the last successful feed update.
        #[prost(int64, tag = "4")]
        pub last_successful_update: i64,
        /// Unix timestamp of the last finished update.
        #[prost(int64, tag = "5")]
        pub last_finished_update: i64,
        /// Whether a feed update for this feed is currently running.
        #[prost(bool, tag = "6")]
        pub currently_running: bool,
    }
}
/// Request payload for the reset scheduler endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetSchedulerRequest {}
/// Response payload for the reset scheduler endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetSchedulerReply {}
/// Request payload for the get log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogLevelRequest {}
/// Response payload for the get log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogLevelReply {
    /// Current log level.
    #[prost(enumeration = "LogLevel", tag = "2")]
    pub log_level: i32,
}
/// Request payload for the set log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLogLevelRequest {
    /// New log level.
    #[prost(enumeration = "LogLevel", tag = "2")]
    pub log_level: i32,
}
/// Response payload for the set log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLogLevelReply {}
/// Supported log levels in Transiter.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    Info = 0,
    Debug = 1,
    Warn = 2,
    Error = 3,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogLevel::Info => "INFO",
            LogLevel::Debug => "DEBUG",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFO" => Some(Self::Info),
            "DEBUG" => Some(Self::Debug),
            "WARN" => Some(Self::Warn),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
