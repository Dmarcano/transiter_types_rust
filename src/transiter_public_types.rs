// This file is @generated by prost-build.
/// Request payload for the entrypoint endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrypointRequest {}
/// Response payload for the entrypoint endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrypointReply {
    /// Version and other information about this Transiter binary.
    #[prost(message, optional, tag = "1")]
    pub transiter: ::core::option::Option<entrypoint_reply::TransiterDetails>,
    /// Systems that are installed in this Transiter instance.
    #[prost(message, optional, tag = "2")]
    pub systems: ::core::option::Option<ChildResources>,
}
/// Nested message and enum types in `EntrypointReply`.
pub mod entrypoint_reply {
    /// Message containing version information about a Transiter binary.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransiterDetails {
        /// The version of the Transiter binary this instance is running.
        #[prost(string, tag = "1")]
        pub version: ::prost::alloc::string::String,
        /// URL of the Transiter GitHub repository.
        #[prost(string, tag = "4")]
        pub url: ::prost::alloc::string::String,
    }
}
/// Request payload for the list systems endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSystemsRequest {}
/// Response payload for the list systems endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSystemsReply {
    /// List of systems.
    #[prost(message, repeated, tag = "1")]
    pub systems: ::prost::alloc::vec::Vec<System>,
}
/// Request payload for the get system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemRequest {
    /// ID of the system to get.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Request payload for the list agencies endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgenciesRequest {
    /// ID of the system for which to list agencies.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list agencies endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAgenciesReply {
    /// List of agencies.
    #[prost(message, repeated, tag = "1")]
    pub agencies: ::prost::alloc::vec::Vec<Agency>,
}
/// Request payload for the get agency endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgencyRequest {
    /// ID of the system the agency is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the agency.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub agency_id: ::prost::alloc::string::String,
}
/// Request payload for the list stops endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStopsRequest {
    /// ID of the system for which to list stops.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// The type of search to perform when listing stops.
    #[prost(enumeration = "list_stops_request::SearchMode", optional, tag = "13")]
    pub search_mode: ::core::option::Option<i32>,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "8")]
    pub only_return_specified_ids: bool,
    /// If true, only return stops whose IDs are specified in the repeated `id` field.
    /// Only supported when the search mode is ID.
    #[prost(bool, tag = "15")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true.
    /// It is an error to populate this field if `filter_by_id` is false.
    /// Only supported when the search mode is ID.
    #[prost(string, repeated, tag = "9")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, only return stops whose types are specified in the repeated `type` field.
    #[prost(bool, tag = "16")]
    pub filter_by_type: bool,
    /// Types to filter by if `filter_by_type` is set to true.
    /// It is an error to populate this field if `filter_by_id` is false.
    #[prost(enumeration = "stop::Type", repeated, tag = "17")]
    pub r#type: ::prost::alloc::vec::Vec<i32>,
    /// ID of the first stop to return. If not set, the stop with the smallest ID will be first.
    /// Only supported when the search mode is ID.
    #[prost(string, optional, tag = "2")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of stops to return.
    /// This is supported in all search modes.
    /// For performance reasons, if it is larger than 100 it is rounded down to 100.
    #[prost(int32, optional, tag = "3")]
    pub limit: ::core::option::Option<i32>,
    /// If true, the stop times field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_stop_times: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "6")]
    pub skip_alerts: bool,
    /// If true, the transfers field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "7")]
    pub skip_transfers: bool,
    /// The maximum distance in kilometers that a stop must be from
    /// latitude, longitude to be listed when using DISTANCE search mode.
    #[prost(double, optional, tag = "10")]
    pub max_distance: ::core::option::Option<f64>,
    /// The latitude relative to the returned stops when using DISTANCE search mode.
    #[prost(double, optional, tag = "11")]
    pub latitude: ::core::option::Option<f64>,
    /// The longitude relative to the returned stops when using DISTANCE search mode.
    #[prost(double, optional, tag = "12")]
    pub longitude: ::core::option::Option<f64>,
}
/// Nested message and enum types in `ListStopsRequest`.
pub mod list_stops_request {
    /// The possible search modes when listing stops.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchMode {
        /// Return a paginated list of stops sorted by stop ID.
        Id = 0,
        /// Return all stops within max_distance of (latitude, longitude), sorted by the distance.
        Distance = 1,
    }
    impl SearchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchMode::Id => "ID",
                SearchMode::Distance => "DISTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID" => Some(Self::Id),
                "DISTANCE" => Some(Self::Distance),
                _ => None,
            }
        }
    }
}
/// Response payload for the list stops endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStopsReply {
    /// List of stops.
    #[prost(message, repeated, tag = "1")]
    pub stops: ::prost::alloc::vec::Vec<Stop>,
    /// ID of the next stop to return, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get stop endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStopRequest {
    /// ID of the system the stop is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the stop.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub stop_id: ::prost::alloc::string::String,
    /// If true, the stop times field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_stop_times: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "6")]
    pub skip_alerts: bool,
    /// If true, the transfers field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "7")]
    pub skip_transfers: bool,
}
/// Request payload for the list routes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesRequest {
    /// ID of the system for which to list routes.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If true, the estimated headway fields will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "2")]
    pub skip_estimated_headways: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "3")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_alerts: bool,
}
/// Response payload for the list routes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesReply {
    /// List of routes.
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<Route>,
}
/// Request payload for the get route endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRouteRequest {
    /// ID of the system the route is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
    /// If true, the estimated headway field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "3")]
    pub skip_estimated_headways: bool,
    /// If true, the service maps field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "4")]
    pub skip_service_maps: bool,
    /// If true, the alerts field will not be populated.
    /// This will generally make the response faster to generate.
    #[prost(bool, tag = "5")]
    pub skip_alerts: bool,
}
/// Request payload for the list trips endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTripsRequest {
    /// ID of the system the route is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route for which to list trips
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
}
/// Response payload for the list trips endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTripsReply {
    /// List of trips.
    #[prost(message, repeated, tag = "1")]
    pub trips: ::prost::alloc::vec::Vec<Trip>,
}
/// Request payload for the list alerts endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertsRequest {
    /// ID of the system for which to list alerts.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If non-empty, only alerts with the provided IDs are returned.
    /// This is interpreted as a filtering condition, so it is not an error to provide non-existent IDs.
    ///
    /// If empty, all alerts in the system are returned.
    /// TODO: add a boolean filter_on_alert_ids field
    #[prost(string, repeated, tag = "2")]
    pub alert_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response payload for the list alerts endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlertsReply {
    /// List of alerts.
    #[prost(message, repeated, tag = "1")]
    pub alerts: ::prost::alloc::vec::Vec<Alert>,
}
/// Request payload for the get alert endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAlertRequest {
    /// ID of the system the alert is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the alert.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub alert_id: ::prost::alloc::string::String,
}
/// Request payload for the get trip endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTripRequest {
    /// ID of the system the trip is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the route the trip is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub route_id: ::prost::alloc::string::String,
    /// ID of the route.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "3")]
    pub trip_id: ::prost::alloc::string::String,
}
/// Request payload for the list feeds endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedsRequest {
    /// ID of the system for which to list feeds.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list feeds endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedsReply {
    /// List of feeds.
    #[prost(message, repeated, tag = "1")]
    pub feeds: ::prost::alloc::vec::Vec<Feed>,
}
/// Request payload for the get feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedRequest {
    /// ID of the system the feed is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the feed.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub feed_id: ::prost::alloc::string::String,
}
/// Request payload for the list transfers endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersRequest {
    /// ID of the system for which to list transfers.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the list transfers endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersReply {
    /// List of transfers.
    #[prost(message, repeated, tag = "1")]
    pub transfers: ::prost::alloc::vec::Vec<Transfer>,
}
/// Request payload for the get transfer endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransferRequest {
    /// ID of the system the transfer is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the transfer.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub transfer_id: ::prost::alloc::string::String,
}
/// Request payload for the list vehicles endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVehiclesRequest {
    /// ID of the system for which to list vehicles.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// The type of search to perform when listing vehicles.
    #[prost(enumeration = "list_vehicles_request::SearchMode", optional, tag = "2")]
    pub search_mode: ::core::option::Option<i32>,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub only_return_specified_ids: bool,
    /// If true, only return vehicles whose IDs are specified in the repeated `id` field.
    /// Only supported when the search mode is ID.
    #[prost(bool, tag = "10")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true. It is an error to
    /// populate this field if `filter_by_id` is false.
    /// Only supported when the search mode is ID.
    #[prost(string, repeated, tag = "4")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ID of the first vehicle to return. If not set, the vehicle with the smallest ID will be first.
    /// Only supported when the search mode is ID.
    #[prost(string, optional, tag = "5")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of vehicles to return.
    /// This is supported in all search modes.
    /// For performance reasons, if it is larger than 100 it is rounded down to 100.
    #[prost(int32, optional, tag = "6")]
    pub limit: ::core::option::Option<i32>,
    /// The maximum distance in kilometers that a vehicle must be from
    /// latitude, longitude to be listed when using DISTANCE search mode.
    #[prost(double, optional, tag = "7")]
    pub max_distance: ::core::option::Option<f64>,
    /// The latitude relative to the returned vehicles when using DISTANCE search mode.
    #[prost(double, optional, tag = "8")]
    pub latitude: ::core::option::Option<f64>,
    /// The longitude relative to the returned vehicles when using DISTANCE search mode.
    #[prost(double, optional, tag = "9")]
    pub longitude: ::core::option::Option<f64>,
}
/// Nested message and enum types in `ListVehiclesRequest`.
pub mod list_vehicles_request {
    /// Available search modes when listing vehicles.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchMode {
        /// Return a paginated list of vehicles sorted by vehicle ID.
        Id = 0,
        /// Return all vehicles within max_distance of (latitude, longitude), sorted by the distance.
        Distance = 1,
    }
    impl SearchMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchMode::Id => "ID",
                SearchMode::Distance => "DISTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID" => Some(Self::Id),
                "DISTANCE" => Some(Self::Distance),
                _ => None,
            }
        }
    }
}
/// Response payload for the list vehicles endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVehiclesReply {
    /// List of vehicles.
    #[prost(message, repeated, tag = "1")]
    pub vehicles: ::prost::alloc::vec::Vec<Vehicle>,
    /// ID of the next vehicle to return, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get vehicle endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVehicleRequest {
    /// ID of the system the vehicle is in.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the vehicle.
    ///
    /// This is a URL parameter in the HTTP API.
    #[prost(string, tag = "2")]
    pub vehicle_id: ::prost::alloc::string::String,
}
/// Request payload for the list shapes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListShapesRequest {
    /// System to list shapes for.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// Deprecated: use `filter_by_id` instead.
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub only_return_specified_ids: bool,
    /// If true, only return shapes whose IDs are specified in the repeated `id` field.
    #[prost(bool, tag = "6")]
    pub filter_by_id: bool,
    /// IDs to return if `filter_by_id` is set to true. It is an error to
    /// populate this field if `filter_by_id` is false.
    #[prost(string, repeated, tag = "3")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ID of the first shape to return. If not set, the shape with the smallest ID will be first.
    #[prost(string, optional, tag = "4")]
    pub first_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Maximum number of shapes to return.
    #[prost(int32, optional, tag = "5")]
    pub limit: ::core::option::Option<i32>,
}
/// Response payload for the list shapes endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListShapesReply {
    /// Shapes that were listed.
    #[prost(message, repeated, tag = "1")]
    pub shapes: ::prost::alloc::vec::Vec<Shape>,
    /// ID of the next shape to list, if there are more results.
    #[prost(string, optional, tag = "2")]
    pub next_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request payload for the get shape endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShapeRequest {
    /// System to get shape for.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the shape to get.
    #[prost(string, tag = "2")]
    pub shape_id: ::prost::alloc::string::String,
}
/// The System resource.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct System {
    /// ID of the system as specified in the install request.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the system resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// Name of the system as specified in the system configuration file.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Status of the system.
    #[prost(enumeration = "system::Status", tag = "5")]
    pub status: i32,
    /// The system's agencies.
    #[prost(message, optional, tag = "6")]
    pub agencies: ::core::option::Option<ChildResources>,
    /// The system's feeds.
    #[prost(message, optional, tag = "7")]
    pub feeds: ::core::option::Option<ChildResources>,
    /// The system's routes.
    #[prost(message, optional, tag = "8")]
    pub routes: ::core::option::Option<ChildResources>,
    /// The system's stops.
    #[prost(message, optional, tag = "9")]
    pub stops: ::core::option::Option<ChildResources>,
    /// The system's transfers.
    #[prost(message, optional, tag = "10")]
    pub transfers: ::core::option::Option<ChildResources>,
}
/// Nested message and enum types in `System`.
pub mod system {
    /// Reference type for the system resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
    /// Enum describing the possible statuses of a system.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Unknown status, included for protobuf reasons.
        Unknown = 0,
        /// The system is currently being installed through an asynchronous install request.
        Installing = 1,
        /// The system was successfully installed and is now active.
        Active = 2,
        /// The system was added through an asynchronous install request, but the install failed.
        InstallFailed = 3,
        /// The system is currently being updated through an asynchronous update request.
        Updating = 4,
        /// An asynchronous update of the system failed.
        UpdateFailed = 5,
        /// The system is in the process of being deleted through an asynchronous delete request.
        Deleting = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unknown => "UNKNOWN",
                Status::Installing => "INSTALLING",
                Status::Active => "ACTIVE",
                Status::InstallFailed => "INSTALL_FAILED",
                Status::Updating => "UPDATING",
                Status::UpdateFailed => "UPDATE_FAILED",
                Status::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INSTALLING" => Some(Self::Installing),
                "ACTIVE" => Some(Self::Active),
                "INSTALL_FAILED" => Some(Self::InstallFailed),
                "UPDATING" => Some(Self::Updating),
                "UPDATE_FAILED" => Some(Self::UpdateFailed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// This message contains generic metadata that applies to all resources.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    /// Full path of the resource.
    /// For example, for systems this is `systems/<system_id>`
    /// and for routes it is `systems/<system_id>/routes/<route_id>`.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// URL of the resource.
    /// This is populated if the `X-Transiter-Host` HTTP header is provided in the request.
    /// See [the deployment documentation](../deployment.md#optional-setting-the-transiter-host) for more information
    /// about this header.
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Description of a collection of child resources for a resource.
/// This message only exists to support API discoverability.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildResources {
    /// Number of child resources.
    #[prost(int64, tag = "1")]
    pub count: i64,
    /// Full path of the child resources.
    /// For example, for routes this is `systems/<system_id>/routes`
    /// and for trips it is `systems/<system_id>/routes/<route_id>/trips`.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// URL of the endpoint to list child resources.
    /// This is populated if the `X-Transiter-Host` HTTP header is provided in the request.
    /// See [the deployment documentation](../deployment.md#optional-setting-the-transiter-host) for more information.
    #[prost(string, optional, tag = "4")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
/// The Stop resource.
///
/// This resource corresponds to the [stop type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#stopstxt>).
/// Most of the static fields in the resource come directly from the `stops.txt` table.
/// Transiter adds some additional related fields (transfers, alerts, stop times)
///    and computed fields (service maps).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stop {
    /// ID of the stop. This is the `stop_id` column in `stops.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the stop resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this stop.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Code of the stop. This is the `stop_code` column in `stops.txt`.
    #[prost(string, optional, tag = "4")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the stop. This is the `stop_name` column in `stops.txt`.
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Description of the stop. This is the `stop_desc` column in `stops.txt`.
    #[prost(string, optional, tag = "6")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Zone ID of the stop. This is the `zone_id` column in `stops.txt`.
    #[prost(string, optional, tag = "7")]
    pub zone_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Latitude of the stop. This is the `stop_lat` column in `stops.txt`.
    #[prost(double, optional, tag = "8")]
    pub latitude: ::core::option::Option<f64>,
    /// Longitude of the stop. This is the `stop_lon` column in `stops.txt`.
    #[prost(double, optional, tag = "9")]
    pub longitude: ::core::option::Option<f64>,
    /// URL of a webpage about the stop. This is the `stop_url` column in `stops.txt`.
    #[prost(string, optional, tag = "10")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of the stop. This is the `platform_type` column in `stops.txt`.
    #[prost(enumeration = "stop::Type", tag = "11")]
    #[serde(deserialize_with = "super::Type::from_str")]
    pub r#type: i32,
    /// Parent stop. This is determined using the `parent_station` column in `stops.txt`.
    #[prost(message, optional, tag = "12")]
    pub parent_stop: ::core::option::Option<stop::Reference>,
    /// Child stops. This are determined using the `parent_station` column in `stops.txt`.
    #[prost(message, repeated, tag = "13")]
    pub child_stops: ::prost::alloc::vec::Vec<stop::Reference>,
    /// Timezone of the stop. This is the `stop_timezone` column in `stops.txt`.
    #[prost(string, optional, tag = "14")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
    /// If there is wheelchair boarding for this stop. This is the `wheelchair_boarding` column in `stops.txt`.
    #[prost(bool, optional, tag = "15")]
    pub wheelchair_boarding: ::core::option::Option<bool>,
    /// Platform code of the stop. This is the `platform_code` column in `stops.txt`.
    #[prost(string, optional, tag = "16")]
    pub platform_code: ::core::option::Option<::prost::alloc::string::String>,
    /// List of service maps for this stop.
    #[prost(message, repeated, tag = "17")]
    pub service_maps: ::prost::alloc::vec::Vec<stop::ServiceMap>,
    /// Active alerts for this stop.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/reference/#message-alert>).
    #[prost(message, repeated, tag = "18")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
    /// List of realtime stop times for this stop.
    ///
    /// A stop time is an event at which a trip calls at a stop.
    #[prost(message, repeated, tag = "19")]
    pub stop_times: ::prost::alloc::vec::Vec<StopTime>,
    /// Transfers out of this stop.
    ///
    /// These are determined using the `from_stop_id` field in the GTFS static `transfers.txt` file.
    #[prost(message, repeated, tag = "20")]
    pub transfers: ::prost::alloc::vec::Vec<Transfer>,
    /// List of headsign rules for this stop.
    /// See the message type for more information.
    #[prost(message, repeated, tag = "21")]
    pub headsign_rules: ::prost::alloc::vec::Vec<stop::HeadsignRule>,
}
/// Nested message and enum types in `Stop`.
pub mod stop {
    /// Message describing the service maps view in stops.
    ///
    /// See the [service maps documentation](../systems.md#service-maps) for more information on this
    /// message and the associated field.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceMap {
        /// Config ID of the service map, as specified in the system configuration file.
        #[prost(string, tag = "1")]
        pub config_id: ::prost::alloc::string::String,
        /// List of routes which call at this stop.
        ///
        /// This list may be empty, in which case the stop has no service in the service map.
        #[prost(message, repeated, tag = "2")]
        pub routes: ::prost::alloc::vec::Vec<super::route::Reference>,
    }
    /// Message describing a headsign rule.
    ///
    /// This message is currently only used for the New York City subway.
    /// The data in it comes from the MTA's [subway stations feed](<https://data.ny.gov/Transportation/MTA-Subway-Stations/39hk-dx4f>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HeadsignRule {
        /// Stop the rule is for.
        #[prost(message, optional, tag = "1")]
        pub stop: ::core::option::Option<Reference>,
        /// Priority of the rule (lower is higher priority).
        #[prost(int32, tag = "2")]
        pub priority: i32,
        /// NYCT track.
        #[prost(string, optional, tag = "3")]
        pub track: ::core::option::Option<::prost::alloc::string::String>,
        /// Headsign for trains arriving on the track.
        #[prost(string, tag = "4")]
        pub headsign: ::prost::alloc::string::String,
    }
    /// Reference type for the stop resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, optional, tag = "4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Enum describing the possible stop types
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Stop = 0,
        Station = 1,
        EntranceOrExit = 2,
        GenericNode = 3,
        BoardingArea = 4,
        Platform = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Stop => "STOP",
                Type::Station => "STATION",
                Type::EntranceOrExit => "ENTRANCE_OR_EXIT",
                Type::GenericNode => "GENERIC_NODE",
                Type::BoardingArea => "BOARDING_AREA",
                Type::Platform => "PLATFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOP" => Some(Self::Stop),
                "STATION" => Some(Self::Station),
                "ENTRANCE_OR_EXIT" => Some(Self::EntranceOrExit),
                "GENERIC_NODE" => Some(Self::GenericNode),
                "BOARDING_AREA" => Some(Self::BoardingArea),
                "PLATFORM" => Some(Self::Platform),
                _ => None,
            }
        }
    }
}
/// Message describing a realtime stop time.
///
/// A stop time is an event in which a trip calls at a stop.
/// This message corresponds to the [GTFS realtime `StopTimeUpdate`
/// message](<https://gtfs.org/realtime/reference/#message-stoptimeupdate>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTime {
    /// The stop.
    #[prost(message, optional, tag = "1")]
    pub stop: ::core::option::Option<stop::Reference>,
    /// The trip.
    #[prost(message, optional, tag = "2")]
    pub trip: ::core::option::Option<trip::Reference>,
    /// The last stop the trip calls at.
    /// Only populated for StopTime messages returned in Stops.
    /// For Trip messages, the destination can be determined from the list of stop times in the message.
    #[prost(message, optional, tag = "9")]
    pub destination: ::core::option::Option<stop::Reference>,
    /// Vehicle corresponding to this trip, if set.
    /// Only populated for StopTime messages returned in Stops.
    /// For Trip messages, the vehicle is contained in the message itself.
    #[prost(message, optional, tag = "10")]
    pub vehicle: ::core::option::Option<vehicle::Reference>,
    /// Arrival time.
    #[prost(message, optional, tag = "3")]
    pub arrival: ::core::option::Option<stop_time::EstimatedTime>,
    /// Departure time.
    #[prost(message, optional, tag = "4")]
    pub departure: ::core::option::Option<stop_time::EstimatedTime>,
    /// If this stop time is in the future.
    /// This field is *not* based on the arrival or departure time.
    /// Instead, a stop time is considered in the future if it appeared in the most recent
    /// GTFS realtime feed for its trip.
    /// When this stop time disappears from the trip, Transiter marks it as in the past and freezes
    /// its data.
    #[prost(bool, tag = "5")]
    pub future: bool,
    /// Stop sequence.
    #[prost(int32, tag = "6")]
    pub stop_sequence: i32,
    /// Headsign.
    #[prost(string, optional, tag = "7")]
    pub headsign: ::core::option::Option<::prost::alloc::string::String>,
    /// Track, from the NYCT realtime extension.
    #[prost(string, optional, tag = "8")]
    pub track: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StopTime`.
pub mod stop_time {
    /// Message describing the arrival or departure time of a stop time.
    /// This corresponds to the [GTFS realtime `StopTimeEvent`
    /// message](<https://gtfs.org/realtime/reference/#message-stoptimeevent>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EstimatedTime {
        /// Time of arrival.
        #[prost(int64, optional, tag = "1")]
        pub time: ::core::option::Option<i64>,
        /// Delay from the scheduled time.
        #[prost(int32, optional, tag = "2")]
        pub delay: ::core::option::Option<i32>,
        /// Measure of the uncertainty of the data in this message.
        #[prost(int32, optional, tag = "3")]
        pub uncertainty: ::core::option::Option<i32>,
    }
}
/// The Trip resource.
///
/// This resource corresponds to the [trip update type in the GTFS static
/// specification](<https://gtfs.org/realtime/reference/#message-tripupdate>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trip {
    /// ID of the trip.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the trip resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// Route corresponding to this trip.
    /// This is the parent resource in Transiter's resource hierarchy.
    /// It is determined using the `route_id` field in the GTFS realtime feed.
    #[prost(message, optional, tag = "3")]
    pub route: ::core::option::Option<route::Reference>,
    /// Time the trip started at.
    #[prost(int64, optional, tag = "4")]
    pub started_at: ::core::option::Option<i64>,
    /// Vehicle corresponding to the trip.
    #[prost(message, optional, tag = "5")]
    pub vehicle: ::core::option::Option<vehicle::Reference>,
    /// Direction ID of the trip.
    #[prost(bool, tag = "6")]
    pub direction_id: bool,
    /// Stop times of the trip.
    #[prost(message, repeated, tag = "7")]
    pub stop_times: ::prost::alloc::vec::Vec<StopTime>,
    /// Shape of the trip.
    #[prost(message, optional, tag = "8")]
    pub shape: ::core::option::Option<shape::Reference>,
    /// Active alerts for this trip.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/feed-entities/service-alerts/#service-alerts>).
    #[prost(message, repeated, tag = "9")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
}
/// Nested message and enum types in `Trip`.
pub mod trip {
    /// Reference type for the trip resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub route: ::core::option::Option<super::route::Reference>,
        /// The last stop this trip calls at.
        /// This field is only populated in trip references in StopTime messages.
        /// It is deprecated in favor of the destination field on the StopTime message itself,
        ///     and will be removed in v2.
        #[deprecated]
        #[prost(message, optional, tag = "4")]
        pub destination: ::core::option::Option<super::stop::Reference>,
        /// Vehicle corresponding to this trip.
        /// This field is only populated in trip references in StopTime messages.
        /// It is deprecated in favor of the destination field on the StopTime message itself,
        ///     and will be removed in v2.
        #[deprecated]
        #[prost(message, optional, tag = "5")]
        pub vehicle: ::core::option::Option<super::vehicle::Reference>,
        /// Same as the parent message.
        #[prost(bool, tag = "6")]
        pub direction_id: bool,
    }
}
/// The Vehicle resource.
///
/// This resource corresponds to the [vehicle position type in the GTFS static
/// specification](<https://gtfs.org/realtime/reference/#message-vehicleposition>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vehicle {
    /// A unique ID for the vehicle.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// A reference to the vehicle's trip.
    #[prost(message, optional, tag = "2")]
    pub trip: ::core::option::Option<trip::Reference>,
    /// The vehicle's current latitude.
    #[prost(double, optional, tag = "3")]
    pub latitude: ::core::option::Option<f64>,
    /// The vehicle's current longitude.
    #[prost(double, optional, tag = "4")]
    pub longitude: ::core::option::Option<f64>,
    /// The vehicle's current bearing.
    #[prost(float, optional, tag = "5")]
    pub bearing: ::core::option::Option<f32>,
    /// The vehicle's current odometer reading.
    #[prost(double, optional, tag = "6")]
    pub odometer: ::core::option::Option<f64>,
    /// The vehicle's current speed.
    #[prost(float, optional, tag = "7")]
    pub speed: ::core::option::Option<f32>,
    /// The stop sequence index of the vehicle's current stop.
    #[prost(int32, optional, tag = "8")]
    pub stop_sequence: ::core::option::Option<i32>,
    /// A reference to the vehicle's current stop.
    #[prost(message, optional, tag = "9")]
    pub stop: ::core::option::Option<stop::Reference>,
    /// The vehicle's current status.
    #[prost(enumeration = "vehicle::CurrentStatus", optional, tag = "10")]
    pub current_status: ::core::option::Option<i32>,
    /// The timestamp of the last update to the vehicle's position.
    #[prost(int64, optional, tag = "11")]
    pub updated_at: ::core::option::Option<i64>,
    /// The vehicle's current congestion level.
    #[prost(enumeration = "vehicle::CongestionLevel", tag = "12")]
    pub congestion_level: i32,
    /// The vehicle's current occupancy status.
    #[prost(enumeration = "vehicle::OccupancyStatus", optional, tag = "13")]
    pub occupancy_status: ::core::option::Option<i32>,
    /// The percentage of seats occupied.
    #[prost(int32, optional, tag = "14")]
    pub occupancy_percentage: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Vehicle`.
pub mod vehicle {
    /// Reference type for the vehicle resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
    /// Corresponds to [VehicleStopStatus](<https://gtfs.org/realtime/reference/#enum-vehiclestopstatus>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrentStatus {
        IncomingAt = 0,
        StoppedAt = 1,
        InTransitTo = 2,
    }
    impl CurrentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CurrentStatus::IncomingAt => "INCOMING_AT",
                CurrentStatus::StoppedAt => "STOPPED_AT",
                CurrentStatus::InTransitTo => "IN_TRANSIT_TO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INCOMING_AT" => Some(Self::IncomingAt),
                "STOPPED_AT" => Some(Self::StoppedAt),
                "IN_TRANSIT_TO" => Some(Self::InTransitTo),
                _ => None,
            }
        }
    }
    /// Corresponds to [CongestionLevel](<https://gtfs.org/realtime/reference/#enum-congestionlevel>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CongestionLevel {
        UnknownCongestionLevel = 0,
        RunningSmoothly = 1,
        StopAndGo = 2,
        Congestion = 3,
        SevereCongestion = 4,
    }
    impl CongestionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CongestionLevel::UnknownCongestionLevel => "UNKNOWN_CONGESTION_LEVEL",
                CongestionLevel::RunningSmoothly => "RUNNING_SMOOTHLY",
                CongestionLevel::StopAndGo => "STOP_AND_GO",
                CongestionLevel::Congestion => "CONGESTION",
                CongestionLevel::SevereCongestion => "SEVERE_CONGESTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CONGESTION_LEVEL" => Some(Self::UnknownCongestionLevel),
                "RUNNING_SMOOTHLY" => Some(Self::RunningSmoothly),
                "STOP_AND_GO" => Some(Self::StopAndGo),
                "CONGESTION" => Some(Self::Congestion),
                "SEVERE_CONGESTION" => Some(Self::SevereCongestion),
                _ => None,
            }
        }
    }
    /// Corresponds to [OccupancyStatus](<https://gtfs.org/realtime/reference/#enum-occupancystatus>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OccupancyStatus {
        Empty = 0,
        ManySeatsAvailable = 1,
        FewSeatsAvailable = 2,
        StandingRoomOnly = 3,
        CrushedStandingRoomOnly = 4,
        Full = 5,
        NotAcceptingPassengers = 6,
    }
    impl OccupancyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OccupancyStatus::Empty => "EMPTY",
                OccupancyStatus::ManySeatsAvailable => "MANY_SEATS_AVAILABLE",
                OccupancyStatus::FewSeatsAvailable => "FEW_SEATS_AVAILABLE",
                OccupancyStatus::StandingRoomOnly => "STANDING_ROOM_ONLY",
                OccupancyStatus::CrushedStandingRoomOnly => "CRUSHED_STANDING_ROOM_ONLY",
                OccupancyStatus::Full => "FULL",
                OccupancyStatus::NotAcceptingPassengers => "NOT_ACCEPTING_PASSENGERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EMPTY" => Some(Self::Empty),
                "MANY_SEATS_AVAILABLE" => Some(Self::ManySeatsAvailable),
                "FEW_SEATS_AVAILABLE" => Some(Self::FewSeatsAvailable),
                "STANDING_ROOM_ONLY" => Some(Self::StandingRoomOnly),
                "CRUSHED_STANDING_ROOM_ONLY" => Some(Self::CrushedStandingRoomOnly),
                "FULL" => Some(Self::Full),
                "NOT_ACCEPTING_PASSENGERS" => Some(Self::NotAcceptingPassengers),
                _ => None,
            }
        }
    }
}
/// The Route resource.
///
/// This resource corresponds to the [route type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#routestxt>).
/// Most of the fields in the resource come directly from the `routes.txt` table.
/// Transiter adds some additional related fields (agency, alerts)
///    and computed fields (estimated headway, service maps).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    /// ID of the route. This is the `route_id` column in `routes.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the route resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this route.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Short name of the route. This is the `route_short_name` column in `routes.txt`.
    #[prost(string, optional, tag = "4")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Long name of the route. This is the `route_long_name` column in `routes.txt`.
    #[prost(string, optional, tag = "5")]
    pub long_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Color of the route. This is the `route_color` column in `routes.txt`.
    #[prost(string, tag = "6")]
    pub color: ::prost::alloc::string::String,
    /// Text color of the route. This is the `route_text_color` column in `routes.txt`.
    #[prost(string, tag = "7")]
    pub text_color: ::prost::alloc::string::String,
    /// Description of the route. This is the `route_desc` column in `routes.txt`.
    #[prost(string, optional, tag = "8")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// URL of a web page about the route. This is the `route_url` column in `routes.txt`.
    #[prost(string, optional, tag = "9")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Sort order of the route. This is the `route_sort_order` column in `routes.txt`.
    #[prost(int32, optional, tag = "10")]
    pub sort_order: ::core::option::Option<i32>,
    /// Continuous pickup policy. This is the `continuous_pickup` column in `routes.txt`.
    #[prost(enumeration = "route::ContinuousPolicy", tag = "11")]
    pub continuous_pickup: i32,
    /// Continuous dropoff policy. This is the `continuous_dropoff` column in `routes.txt`.
    #[prost(enumeration = "route::ContinuousPolicy", tag = "12")]
    pub continuous_drop_off: i32,
    /// Type of the route. This is the `route_type` column in `routes.txt`.
    #[prost(enumeration = "route::Type", tag = "13")]
    pub r#type: i32,
    /// Agency this route is associated to.
    ///
    /// This is determined using the `agency_id` column in `routes.txt`.
    #[prost(message, optional, tag = "14")]
    pub agency: ::core::option::Option<agency::Reference>,
    /// Active alerts for this route.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/feed-entities/service-alerts/#service-alerts>).
    #[prost(message, repeated, tag = "15")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
    /// An estimate of the interval of time between consecutive realtime trips, in seconds.
    ///
    /// If there is insufficient data to compute an estimate, the field will be empty.
    ///
    /// The estimate is computed as follows.
    /// For each stop that has realtime trips for the route,
    ///   the list of arrival times for those trips is examined.
    /// The difference between consecutive arrival times is calculated.
    /// If there are `N` trips, there will be `N-1` such arrival time diffs.
    /// The estimated headway is the average of these diffs across
    /// all stops.
    #[prost(int32, optional, tag = "16")]
    pub estimated_headway: ::core::option::Option<i32>,
    /// List of service maps for this route.
    #[prost(message, repeated, tag = "17")]
    pub service_maps: ::prost::alloc::vec::Vec<route::ServiceMap>,
}
/// Nested message and enum types in `Route`.
pub mod route {
    /// Message describing the service maps view in routes.
    ///
    /// See the [service maps documentation](../systems.md#service-maps) for more information on this
    /// message and the associated field.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceMap {
        /// Config ID of the service map, as specified in the system configuration file.
        #[prost(string, tag = "1")]
        pub config_id: ::prost::alloc::string::String,
        /// Ordered list of stops at which this route calls.
        ///
        /// This list may be empty, in which case the route has no service in the service map.
        #[prost(message, repeated, tag = "2")]
        pub stops: ::prost::alloc::vec::Vec<super::stop::Reference>,
    }
    /// Reference type for the route resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, tag = "4")]
        pub color: ::prost::alloc::string::String,
    }
    /// Enum describing possible policies for continuous pickup or drop-off.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContinuousPolicy {
        /// Continuous pickup or drop-off allowed.
        Allowed = 0,
        /// Continuous pickup or drop-off not allowed.
        NotAllowed = 1,
        /// Must phone the agency to arrange continuous pickup or drop-off.
        PhoneAgency = 2,
        /// Must coordinate with driver to arrange continuous pickup or drop-off.
        CoordinateWithDriver = 3,
    }
    impl ContinuousPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContinuousPolicy::Allowed => "ALLOWED",
                ContinuousPolicy::NotAllowed => "NOT_ALLOWED",
                ContinuousPolicy::PhoneAgency => "PHONE_AGENCY",
                ContinuousPolicy::CoordinateWithDriver => "COORDINATE_WITH_DRIVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALLOWED" => Some(Self::Allowed),
                "NOT_ALLOWED" => Some(Self::NotAllowed),
                "PHONE_AGENCY" => Some(Self::PhoneAgency),
                "COORDINATE_WITH_DRIVER" => Some(Self::CoordinateWithDriver),
                _ => None,
            }
        }
    }
    /// Enum describing possible route types.
    /// This corresponds to possible values of the `route_type` column in `routes.txt`.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        LightRail = 0,
        Subway = 1,
        Rail = 2,
        Bus = 3,
        Ferry = 4,
        CableTram = 5,
        AerialLift = 6,
        Funicular = 7,
        TrolleyBus = 11,
        Monorail = 12,
        Unknown = 100,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::LightRail => "LIGHT_RAIL",
                Type::Subway => "SUBWAY",
                Type::Rail => "RAIL",
                Type::Bus => "BUS",
                Type::Ferry => "FERRY",
                Type::CableTram => "CABLE_TRAM",
                Type::AerialLift => "AERIAL_LIFT",
                Type::Funicular => "FUNICULAR",
                Type::TrolleyBus => "TROLLEY_BUS",
                Type::Monorail => "MONORAIL",
                Type::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIGHT_RAIL" => Some(Self::LightRail),
                "SUBWAY" => Some(Self::Subway),
                "RAIL" => Some(Self::Rail),
                "BUS" => Some(Self::Bus),
                "FERRY" => Some(Self::Ferry),
                "CABLE_TRAM" => Some(Self::CableTram),
                "AERIAL_LIFT" => Some(Self::AerialLift),
                "FUNICULAR" => Some(Self::Funicular),
                "TROLLEY_BUS" => Some(Self::TrolleyBus),
                "MONORAIL" => Some(Self::Monorail),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// The feed resource.
///
/// Each feed is defined in the system configuration file.
/// Feeds are included in the public API because there are non-admin use-cases for this resource.
/// For example, an app might publish the staleness of realtime data
///    by checking the last successful feed update time.
///
/// More detailed information on a feed -- its full configuration, and the
///    current status of its periodic updates -- can be retrieved through the
///    [admin API's GetSystemConfig endpoint](admin.md#get-the-config-for-a-system).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Feed {
    /// ID of the feed, as specified in the system configuration file.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the feed resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this feed.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Unix milliseconds timestamp of when the last update of this feed finished.
    /// There are three outcomes for each update:
    ///     successful (new data is retrieved from the transit agency and persisted),
    ///     skipped (the transit agency returned the same data as the last update, so there is nothing to do),
    ///     and failed (something went wrong, e.g. the transit agency's feed is unavailable).
    #[prost(int64, optional, tag = "4")]
    pub last_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last successful update of this feed finished.
    #[prost(int64, optional, tag = "5")]
    pub last_successful_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last skipped update of this feed finished.
    #[prost(int64, optional, tag = "6")]
    pub last_skipped_update_ms: ::core::option::Option<i64>,
    /// Unix milliseconds timestamp of when the last failed update of this feed finished.
    #[prost(int64, optional, tag = "7")]
    pub last_failed_update_ms: ::core::option::Option<i64>,
}
/// Nested message and enum types in `Feed`.
pub mod feed {
    /// Reference type for the feed resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
    }
}
/// The Agency resource.
///
/// This resource corresponds to the [`agency.txt` table in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#agencytxt>).
/// Most of the fields in the resource come directly from the `agency.txt` table.
/// Transiter adds some additional related fields (routes, alerts).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Agency {
    /// ID of the agency. This is the `agency_id` column in `agency.txt`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the agency resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this agency.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Name of the agency. This is the `agency_name` column in `agency.txt`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// URL of the agency. This is the `agency_url` column in `agency.txt`.
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    /// Timezone of the agency. This is the `agency_timezone` column in `agency.txt`.
    #[prost(string, tag = "6")]
    pub timezone: ::prost::alloc::string::String,
    /// Language of the agency. This is the `agency_lang` column in `agency.txt`.
    #[prost(string, optional, tag = "7")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// Phone number of the agency. This is the `agency_phone` column in `agency.txt`.
    #[prost(string, optional, tag = "8")]
    pub phone: ::core::option::Option<::prost::alloc::string::String>,
    /// URL where tickets for the agency's services ban be bought.
    /// This is the `agency_fare_url` column in `agency.txt`.
    #[prost(string, optional, tag = "9")]
    pub fare_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Email address of the agency. This is the `agency_email` column in `agency.txt`.
    #[prost(string, optional, tag = "10")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// List of routes operating under this agency.
    ///
    /// These are determined using the `agency_id` column in `routes.txt`.
    #[prost(message, repeated, tag = "11")]
    pub routes: ::prost::alloc::vec::Vec<route::Reference>,
    /// List of active alerts for the agency.
    ///
    /// These are determined using the `informed_entity` field in
    /// the [GTFS realtime alerts
    /// message](<https://gtfs.org/realtime/reference/#message-alert>).
    #[prost(message, repeated, tag = "12")]
    pub alerts: ::prost::alloc::vec::Vec<alert::Reference>,
}
/// Nested message and enum types in `Agency`.
pub mod agency {
    /// Reference type for the agency resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(string, tag = "4")]
        pub name: ::prost::alloc::string::String,
    }
}
/// The Alert resource.
///
/// This resource corresponds to the [alert message in the GTFS realtime
/// specification](<https://gtfs.org/realtime/reference/#message-alert>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alert {
    /// ID of the alert. This corresponds to the [ID field in the feed entity
    /// message](<https://gtfs.org/realtime/reference/#message-feedentity>)
    /// corresponding to the alert.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the alert resource.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this alert.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<system::Reference>,
    /// Cause of the alert. This corresponds to the `cause` field in the realtime alert message.
    #[prost(enumeration = "alert::Cause", tag = "4")]
    pub cause: i32,
    /// Effect of the alert. This corresponds to the `effect` field in the realtime alert message.
    #[prost(enumeration = "alert::Effect", tag = "5")]
    pub effect: i32,
    /// The current active period, if the alert is currently active.
    /// If the alert is not active this is empty.
    #[prost(message, optional, tag = "6")]
    pub current_active_period: ::core::option::Option<alert::ActivePeriod>,
    /// All active periods for this alert.
    /// Transiter guarantees that these active periods have no overlap.
    #[prost(message, repeated, tag = "7")]
    pub all_active_periods: ::prost::alloc::vec::Vec<alert::ActivePeriod>,
    /// Header of the alert, in zero or more languages.
    /// This corresponds to the `header_text` field in the realtime alert message.
    #[prost(message, repeated, tag = "8")]
    pub header: ::prost::alloc::vec::Vec<alert::Text>,
    /// Description of the alert, in zero or more languages.
    /// This corresponds to the `description_text` field in the realtime alert message.
    #[prost(message, repeated, tag = "9")]
    pub description: ::prost::alloc::vec::Vec<alert::Text>,
    /// URL for additional information about the alert, in zero or more languages.
    /// This corresponds to the `url` field in the realtime alert message.
    #[prost(message, repeated, tag = "10")]
    pub url: ::prost::alloc::vec::Vec<alert::Text>,
}
/// Nested message and enum types in `Alert`.
pub mod alert {
    /// The active period message describes a period when an alert is active.
    /// It corresponds the the [time range message in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#message-timerange>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActivePeriod {
        /// Unix timestamp of the start time of the active period.
        /// If not set, the alert be interpreted
        /// as being always active up to the end time.
        #[prost(int64, optional, tag = "1")]
        pub starts_at: ::core::option::Option<i64>,
        /// Unix timestamp of the end time of the active period.
        /// If not set, the alert be interpreted as being indefinitely active.
        #[prost(int64, optional, tag = "2")]
        pub ends_at: ::core::option::Option<i64>,
    }
    /// The text message describes an alert header/description/URL in a specified language.
    /// It corresponds the the [translation message in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#message-translation>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        /// Content of the text.
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        /// Language of this text.
        #[prost(string, tag = "2")]
        pub language: ::prost::alloc::string::String,
    }
    /// Reference type for the agency resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
        /// Same as the parent message.
        #[prost(message, optional, tag = "3")]
        pub system: ::core::option::Option<super::system::Reference>,
        /// Same as the parent message.
        #[prost(enumeration = "Cause", tag = "4")]
        pub cause: i32,
        /// Same as the parent message.
        #[prost(enumeration = "Effect", tag = "5")]
        pub effect: i32,
    }
    /// Cause is the same as the [cause enum in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#enum-cause>),
    /// except `UNKNOWN_CAUSE` has value 0 instead of 1 to satisfy protobuf3 requirements.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cause {
        UnknownCause = 0,
        OtherCause = 2,
        TechnicalProblem = 3,
        Strike = 4,
        Demonstration = 5,
        Accident = 6,
        Holiday = 7,
        Weather = 8,
        Maintenance = 9,
        Construction = 10,
        PoliceActivity = 11,
        MedicalEmergency = 12,
    }
    impl Cause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Cause::UnknownCause => "UNKNOWN_CAUSE",
                Cause::OtherCause => "OTHER_CAUSE",
                Cause::TechnicalProblem => "TECHNICAL_PROBLEM",
                Cause::Strike => "STRIKE",
                Cause::Demonstration => "DEMONSTRATION",
                Cause::Accident => "ACCIDENT",
                Cause::Holiday => "HOLIDAY",
                Cause::Weather => "WEATHER",
                Cause::Maintenance => "MAINTENANCE",
                Cause::Construction => "CONSTRUCTION",
                Cause::PoliceActivity => "POLICE_ACTIVITY",
                Cause::MedicalEmergency => "MEDICAL_EMERGENCY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_CAUSE" => Some(Self::UnknownCause),
                "OTHER_CAUSE" => Some(Self::OtherCause),
                "TECHNICAL_PROBLEM" => Some(Self::TechnicalProblem),
                "STRIKE" => Some(Self::Strike),
                "DEMONSTRATION" => Some(Self::Demonstration),
                "ACCIDENT" => Some(Self::Accident),
                "HOLIDAY" => Some(Self::Holiday),
                "WEATHER" => Some(Self::Weather),
                "MAINTENANCE" => Some(Self::Maintenance),
                "CONSTRUCTION" => Some(Self::Construction),
                "POLICE_ACTIVITY" => Some(Self::PoliceActivity),
                "MEDICAL_EMERGENCY" => Some(Self::MedicalEmergency),
                _ => None,
            }
        }
    }
    /// Effect is the same as the [effect enum in the GTFS realtime
    /// specification](<https://gtfs.org/realtime/reference/#enum-effect>),
    /// except `UNKNOWN_EFFECT` has value 0 instead of 1 to satisfy protobuf3 requirements.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Effect {
        UnknownEffect = 0,
        NoService = 1,
        ReducedService = 2,
        SignificantDelays = 3,
        Detour = 4,
        AdditionalService = 5,
        ModifiedService = 6,
        OtherEffect = 7,
        StopMoved = 9,
        NoEffect = 10,
        AccessibilityIssue = 11,
    }
    impl Effect {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Effect::UnknownEffect => "UNKNOWN_EFFECT",
                Effect::NoService => "NO_SERVICE",
                Effect::ReducedService => "REDUCED_SERVICE",
                Effect::SignificantDelays => "SIGNIFICANT_DELAYS",
                Effect::Detour => "DETOUR",
                Effect::AdditionalService => "ADDITIONAL_SERVICE",
                Effect::ModifiedService => "MODIFIED_SERVICE",
                Effect::OtherEffect => "OTHER_EFFECT",
                Effect::StopMoved => "STOP_MOVED",
                Effect::NoEffect => "NO_EFFECT",
                Effect::AccessibilityIssue => "ACCESSIBILITY_ISSUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_EFFECT" => Some(Self::UnknownEffect),
                "NO_SERVICE" => Some(Self::NoService),
                "REDUCED_SERVICE" => Some(Self::ReducedService),
                "SIGNIFICANT_DELAYS" => Some(Self::SignificantDelays),
                "DETOUR" => Some(Self::Detour),
                "ADDITIONAL_SERVICE" => Some(Self::AdditionalService),
                "MODIFIED_SERVICE" => Some(Self::ModifiedService),
                "OTHER_EFFECT" => Some(Self::OtherEffect),
                "STOP_MOVED" => Some(Self::StopMoved),
                "NO_EFFECT" => Some(Self::NoEffect),
                "ACCESSIBILITY_ISSUE" => Some(Self::AccessibilityIssue),
                _ => None,
            }
        }
    }
}
/// The Transfer resource.
///
/// This resource corresponds to the [transfer table in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#transferstxt>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transfer {
    /// Unique ID for the transfer.
    /// This is generated by Transiter because in the GTFS static spec transfers do not have IDs.
    #[prost(string, tag = "9")]
    pub id: ::prost::alloc::string::String,
    /// Generic metadata about the transfer resource.
    #[prost(message, optional, tag = "10")]
    pub resource: ::core::option::Option<Resource>,
    /// System corresponding to this transfer.
    /// This is the parent resource in Transiter's resource hierarchy.
    #[prost(message, optional, tag = "11")]
    pub system: ::core::option::Option<system::Reference>,
    /// Beginning stop of the transfer. This is determined using the `from_stop_id` column in `transfers.txt`.
    #[prost(message, optional, tag = "4")]
    pub from_stop: ::core::option::Option<stop::Reference>,
    /// Ending stop of the transfer. This is determined using the `to_stop_id` column in `transfers.txt`.
    #[prost(message, optional, tag = "5")]
    pub to_stop: ::core::option::Option<stop::Reference>,
    /// Type of the transfer.
    #[prost(enumeration = "transfer::Type", tag = "6")]
    pub r#type: i32,
    /// Minimum time required for the transfer, in seconds. This is the `min_transfer_time` column in `transfers.txt`.
    #[prost(int32, optional, tag = "7")]
    pub min_transfer_time: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Transfer`.
pub mod transfer {
    /// Types of transfers.
    /// The supported types are described in the documentation for the `transfer_type` column
    /// in the GTFS static `transfers.txt` table.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Recommended = 0,
        Timed = 1,
        RequiresTime = 2,
        NotPossible = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Recommended => "RECOMMENDED",
                Type::Timed => "TIMED",
                Type::RequiresTime => "REQUIRES_TIME",
                Type::NotPossible => "NOT_POSSIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECOMMENDED" => Some(Self::Recommended),
                "TIMED" => Some(Self::Timed),
                "REQUIRES_TIME" => Some(Self::RequiresTime),
                "NOT_POSSIBLE" => Some(Self::NotPossible),
                _ => None,
            }
        }
    }
}
/// The Shape resource.
///
/// This resource corresponds to the [shape type in the GTFS static
/// specification](<https://gtfs.org/schedule/reference/#shapestxt>).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shape {
    /// Unique ID for the shape.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Ordered list of points that make up the shape.
    #[prost(message, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<shape::ShapePoint>,
}
/// Nested message and enum types in `Shape`.
pub mod shape {
    /// A point within the shape.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ShapePoint {
        /// Latitude of the point.
        #[prost(double, tag = "1")]
        pub latitude: f64,
        /// Longitude of the point.
        #[prost(double, tag = "2")]
        pub longitude: f64,
        /// Distance from the start of the shape to this point.
        #[prost(double, optional, tag = "3")]
        pub distance: ::core::option::Option<f64>,
    }
    /// Reference type for the shape resource.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Same as the parent message.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Same as the parent message.
        #[prost(message, optional, tag = "2")]
        pub resource: ::core::option::Option<super::Resource>,
    }
}
