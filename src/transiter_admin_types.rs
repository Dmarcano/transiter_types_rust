// This file is @generated by prost-build.
/// Request payload for the get system config endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemConfigRequest {
    /// ID of the system whose config is to be retrieved.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Request payload for the install or update system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallOrUpdateSystemRequest {
    /// ID of the system to install or update.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// If true, do not perform an update if the system already exists.
    #[prost(bool, tag = "4")]
    pub install_only: bool,
    #[prost(oneof = "install_or_update_system_request::Config", tags = "2, 3")]
    pub config: ::core::option::Option<install_or_update_system_request::Config>,
}
/// Nested message and enum types in `InstallOrUpdateSystemRequest`.
pub mod install_or_update_system_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Config for the system, in the form or a protobuf message.
        #[prost(message, tag = "2")]
        SystemConfig(super::SystemConfig),
        /// Config for the system, in the form of a YAML file.
        #[prost(message, tag = "3")]
        YamlConfig(super::YamlConfig),
    }
}
/// YamlConfig contains a Transiter system configuration in YAML format.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YamlConfig {
    /// The YAML content.
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    /// Whether the config is a template. If true the config will first be processed
    /// using Go's template library.
    #[prost(bool, tag = "3")]
    pub is_template: bool,
    /// Arguments to pass to Go's template library if the config is a template.
    ///
    /// In general as much information as possible should be in the config itself.
    /// The template args are intended for things like API keys which are secret
    /// and/or different for each person that installs the system.
    #[prost(btree_map = "string, string", tag = "4")]
    pub template_args: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Response payload for the install of update system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallOrUpdateSystemReply {
    /// ID of the system that was installed.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// System configuration that was used for the install.
    /// If the configuration was provided as a YAML file or a YAML template,
    /// the value here represents the fully parsed and expanded configuration.
    #[prost(message, optional, tag = "2")]
    pub system_config: ::core::option::Option<SystemConfig>,
}
/// Request payload for the delete system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSystemRequest {
    /// ID of the system to delete.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
}
/// Response payload for the delete system endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSystemReply {}
/// Configuration for a system.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemConfig {
    /// Name of the system.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Configuration for the system's feeds.
    #[prost(message, repeated, tag = "2")]
    pub feeds: ::prost::alloc::vec::Vec<FeedConfig>,
    /// Configuration for the system's service maps.
    #[prost(message, repeated, tag = "3")]
    pub service_maps: ::prost::alloc::vec::Vec<ServiceMapConfig>,
}
/// Configuration for a transit system data feed.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedConfig {
    /// Identifier of this feed config.
    /// This must be unique within the system.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The type of the feed.
    /// Allowable values are `GTFS_STATIC`, `GTFS_REALTIME` and `NYCT_SUBWAY_CSV`.
    ///
    /// The are possible future plans to support plugging in additional custom types at build time.
    /// This is why the field is a string and not an enum.
    #[prost(string, tag = "13")]
    pub r#type: ::prost::alloc::string::String,
    /// Deprecated: use `type` instead.
    #[deprecated]
    #[prost(string, tag = "8")]
    pub parser: ::prost::alloc::string::String,
    /// Additional options GTFS realtime feeds.
    #[prost(message, optional, tag = "9")]
    pub gtfs_realtime_options: ::core::option::Option<GtfsRealtimeOptions>,
    /// Required for install specifies whether an update should be performed for this feed during system install.
    /// If true, an update is performed and if the update fails the installation fails.
    ///
    /// If unspecified, defaults to false for GTFS realtime feeds and true for all other
    /// types of feeds.
    #[prost(bool, optional, tag = "2")]
    pub required_for_install: ::core::option::Option<bool>,
    /// The scheduling policy to use for this feed.
    ///
    /// If unspecified, it takes the value `DEFAULT``.
    #[prost(enumeration = "feed_config::SchedulingPolicy", tag = "14")]
    pub scheduling_policy: i32,
    /// Deprecated: use `scheduling_policy` instead.
    #[deprecated]
    #[prost(enumeration = "feed_config::SchedulingPolicy", tag = "3")]
    pub update_strategy: i32,
    /// For feeds with a `PERIODIC` scheduling policy, the update period.
    ///
    /// If unspecified, defaults to 5 seconds.
    #[prost(int64, optional, tag = "10")]
    pub periodic_update_period_ms: ::core::option::Option<i64>,
    /// Deprecated: use `periodic_update_period_ms` instead.
    #[deprecated]
    #[prost(double, optional, tag = "4")]
    pub update_period_s: ::core::option::Option<f64>,
    /// For feeds with a `DAILY` scheduling policy,
    /// the time of day in the form HH:MM at which to perform an update.
    ///
    /// If unspecified, defaults to 03:00 for the first feed in the system, 03:10 for the second feed,
    /// and so on.
    /// The idea of the default is to run at night when the system is either quiet or not running.
    /// The staggering is to avoid updates stepping on each other, and to spread out the load.
    #[prost(string, tag = "11")]
    pub daily_update_time: ::prost::alloc::string::String,
    /// For feeds with a `DAILY` scheduling policy,
    /// the timezone for the time of day specified in the `daily_update_time`.
    ///
    /// If empty, a default is provided as follows.
    /// The scheduler lists the agencies for the system in order of ID and uses
    /// the first valid timezone it finds.
    /// Given the GTFS static specification this should always work.
    /// Moreover, all agencies should have the same timezone so listing in order of ID shouldn't matter.
    /// But in reality it may not work.
    /// If there is no valid agency timezones, the scheduler will log a warning and fall back to UTC.
    #[prost(string, tag = "12")]
    pub daily_update_timezone: ::prost::alloc::string::String,
    /// URL at which the feed can be downloaded using a HTTP GET request.
    /// Transiter does not currently support non-GET requests.
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    /// Timeout to enforce for the request to the feed URL. If not specified, defaults to 5 seconds.
    #[prost(int64, optional, tag = "6")]
    pub request_timeout_ms: ::core::option::Option<i64>,
    /// HTTP headers to send in the request.
    #[prost(btree_map = "string, string", tag = "7")]
    pub http_headers: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Additional options for NYCT Subway feeds.
    #[prost(message, optional, tag = "15")]
    pub nyct_subway_options: ::core::option::Option<feed_config::NyctSubwayOptions>,
}
/// Nested message and enum types in `FeedConfig`.
pub mod feed_config {
    /// Additional options for NYCT Subway CSV feeds.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctSubwayOptions {
        /// If true, infer the 'wheelchair_boarding' field from this feed.
        ///
        /// Historically, this information is not set in the NYC Subway GTFS feed, but
        /// is included in the extended NYCT_SUBWAY_CSV feed.
        ///
        /// To use the data from the CSV feed, set thie field to true on that feed and
        /// false on the GTFS static feed. If this field is not set on either feed,
        /// the GTFS static feed will be used.
        ///
        /// Avoid setting this field to true on both feeds, as this will result in
        /// non-deterministic behavior, since feed updates are not guaranteed to be ordered
        /// after initial system installation.
        #[prost(bool, tag = "1")]
        pub use_accessibility_info: bool,
    }
    /// Transiter runs a background task called the scheduler which performs feed updates automatically.
    /// A scheduling policy determines when the scheduler will perform feed updates for this feed.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchedulingPolicy {
        /// Use the default policy, which is PERIODIC for GTFS realtime feeds and DAILY for all other feeds.
        Default = 0,
        /// Perform an update periodically, with the period specified in the `periodic_update_period_ms` field.
        Periodic = 1,
        /// Perform an update once a day, with the time of day specified in the `daily_update_time` field.
        Daily = 2,
        /// Don't perform updates in the scheduler. Updates can always be triggered manually using the admin API.
        None = 3,
    }
    impl SchedulingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SchedulingPolicy::Default => "DEFAULT",
                SchedulingPolicy::Periodic => "PERIODIC",
                SchedulingPolicy::Daily => "DAILY",
                SchedulingPolicy::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "PERIODIC" => Some(Self::Periodic),
                "DAILY" => Some(Self::Daily),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Message describing additional options for the GTFS realtime feeds.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GtfsRealtimeOptions {
    /// GTFS realtime extension to use.
    #[prost(enumeration = "gtfs_realtime_options::Extension", tag = "1")]
    pub extension: i32,
    /// Options for the NYCT trips extension.
    /// Ignored if the extension field is not `NYCT_TRIPS`.
    #[prost(message, optional, tag = "2")]
    pub nyct_trips_options: ::core::option::Option<
        gtfs_realtime_options::NyctTripsOptions,
    >,
    /// Options for the NYCT alerts extension.
    /// Ignored if the extension field is not `NYCT_ALERTS`.
    #[prost(message, optional, tag = "3")]
    pub nyct_alerts_options: ::core::option::Option<
        gtfs_realtime_options::NyctAlertsOptions,
    >,
    /// If true, stop sequences in the GTFS realtime feed data are ignored, and
    /// alternative stop sequences are generated and assigned by Transiter.
    /// This setting is designed for buggy GTFS realtime feeds in which
    /// stop sequences (incorrectly) change between updates. In many cases
    /// Transiter is able to generate stop sequences that are correct and
    /// stable across updates.
    ///
    /// This should not be used for systems where a trip can call at the same
    /// stop multiple times.
    #[prost(bool, tag = "4")]
    pub reassign_stop_sequences: bool,
}
/// Nested message and enum types in `GtfsRealtimeOptions`.
pub mod gtfs_realtime_options {
    /// Options for the NYCT trips extension.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctTripsOptions {
        /// Filter out trips which are scheduled to run in the past but have no assigned trip and haven't started.
        #[prost(bool, tag = "1")]
        pub filter_stale_unassigned_trips: bool,
        /// The raw MTA data has a bug in which the M train platforms are reported incorrectly for stations
        /// in Williamsburg and Bushwick that the M shares with the J train. In the raw data, M trains going towards
        /// the Williamsburg bridge stop at M11N, but J trains going towards the bridge stop at M11S. By default
        /// this extension fixes these platforms for the M train, so M11N becomes M11S. This fix can be disabled
        /// by setting this option to true.
        #[prost(bool, tag = "2")]
        pub preserve_m_train_platforms_in_bushwick: bool,
    }
    /// Options for the NYCT alerts extension.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NyctAlertsOptions {
        /// Deduplication policy for elevator alerts.
        #[prost(
            enumeration = "nyct_alerts_options::ElevatorAlertsDeduplicationPolicy",
            tag = "1"
        )]
        pub elevator_alerts_deduplication_policy: i32,
        /// If true, the stop IDs in alerts will always be converted to point to stations.
        /// E.g., if the alert is for the stop F20N (northbound F platform at Bergen St.)
        /// it will be transformed to be for stop F20 (Bergen St. station).
        #[prost(bool, tag = "2")]
        pub elevator_alerts_inform_using_station_ids: bool,
        /// When there are no trains running for a route due to the standard timetable (e.g., there are no C trains
        /// overnight), the MTA publishes an alert. Arguably this is not really an alert because this information is
        /// already in the timetable.
        /// If true, these alerts are skipped.
        #[prost(bool, tag = "3")]
        pub skip_timetabled_no_service_alerts: bool,
        /// The NYCT alerts extension contains many fields like "time alert created at" that don't map to fields in
        /// the standard GTFS realtime protobuf. If true, these fields are put in a json blob and included as an
        /// alert description.
        #[prost(bool, tag = "4")]
        pub add_nyct_metadata: bool,
    }
    /// Nested message and enum types in `NyctAlertsOptions`.
    pub mod nyct_alerts_options {
        /// Available deduplication policies for elevator alerts.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ElevatorAlertsDeduplicationPolicy {
            NoDeduplication = 0,
            DeduplicateInStation = 1,
            DeduplicateInComplex = 2,
        }
        impl ElevatorAlertsDeduplicationPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ElevatorAlertsDeduplicationPolicy::NoDeduplication => {
                        "NO_DEDUPLICATION"
                    }
                    ElevatorAlertsDeduplicationPolicy::DeduplicateInStation => {
                        "DEDUPLICATE_IN_STATION"
                    }
                    ElevatorAlertsDeduplicationPolicy::DeduplicateInComplex => {
                        "DEDUPLICATE_IN_COMPLEX"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_DEDUPLICATION" => Some(Self::NoDeduplication),
                    "DEDUPLICATE_IN_STATION" => Some(Self::DeduplicateInStation),
                    "DEDUPLICATE_IN_COMPLEX" => Some(Self::DeduplicateInComplex),
                    _ => None,
                }
            }
        }
    }
    /// Supported GTFS realtime extensions.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Extension {
        NoExtension = 0,
        NyctTrips = 1,
        NyctAlerts = 2,
    }
    impl Extension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Extension::NoExtension => "NO_EXTENSION",
                Extension::NyctTrips => "NYCT_TRIPS",
                Extension::NyctAlerts => "NYCT_ALERTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_EXTENSION" => Some(Self::NoExtension),
                "NYCT_TRIPS" => Some(Self::NyctTrips),
                "NYCT_ALERTS" => Some(Self::NyctAlerts),
                _ => None,
            }
        }
    }
}
/// Description of the configuration for a collection of service maps.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceMapConfig {
    /// Identifier of this service maps config.
    /// This must be unique within the system.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Source of the service maps built using this config.
    #[prost(enumeration = "service_map_config::Source", tag = "2")]
    pub source: i32,
    /// The threshold setting is used to exclude one-off trip schedules from service maps.
    /// When calculating a service map, all trips are bucketed based on their schedule.
    /// If the threshold is 0.2, trips are only included if the corresponding bucket contains
    /// at least 20% of the trips. In particular, a one-off trip whose bucket only contains
    /// itself will be excluded if there are many other trips.
    ///
    /// Note that a trip's schedule is reversed if needed based on the direction ID.
    #[prost(double, tag = "3")]
    pub threshold: f64,
    /// Additional options relevant for static service maps only.
    #[prost(message, optional, tag = "4")]
    pub static_options: ::core::option::Option<service_map_config::StaticOptions>,
}
/// Nested message and enum types in `ServiceMapConfig`.
pub mod service_map_config {
    /// Description of options relevant for static service maps only.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StaticOptions {
        /// If specified, only include trips that start earlier than this time.
        /// The time is specified as a number of hours after midnight; i.e., 2:30am is '2.5'.
        #[prost(double, optional, tag = "1")]
        pub starts_earlier_than: ::core::option::Option<f64>,
        /// If specified, only include trips that start later than this time.
        #[prost(double, optional, tag = "2")]
        pub starts_later_than: ::core::option::Option<f64>,
        /// If specified, only include trips that end earlier than this time.
        #[prost(double, optional, tag = "3")]
        pub ends_earlier_than: ::core::option::Option<f64>,
        /// If specified, only include trips that end later than this time.
        #[prost(double, optional, tag = "4")]
        pub ends_later_than: ::core::option::Option<f64>,
        /// If specified, only include trips which run on at least one of the provided days.
        /// If left empty, no trip filtering is provided.
        #[prost(string, repeated, tag = "5")]
        pub days: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Source describes the possible sources for service maps.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        /// Build the service maps using the GTFS static data.
        Static = 0,
        /// Build the service maps using the GTFS realtime data.
        Realtime = 1,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Static => "STATIC",
                Source::Realtime => "REALTIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATIC" => Some(Self::Static),
                "REALTIME" => Some(Self::Realtime),
                _ => None,
            }
        }
    }
}
/// Request payload for the update feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeedRequest {
    /// ID of the system containing the feed to update.
    #[prost(string, tag = "1")]
    pub system_id: ::prost::alloc::string::String,
    /// ID of the feed to update.
    #[prost(string, tag = "2")]
    pub feed_id: ::prost::alloc::string::String,
    /// If true, a full feed update will be performed even if the downloaded data is identical
    /// to the last update for this feed.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// Description of a feed update operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedUpdate {
    /// ID of the feed update. This is a randomly generated UUID.
    /// It can be used to find server logs for the update operation.
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The feed configuration that was used to perform the feed update.
    #[prost(message, optional, tag = "27")]
    pub feed_config: ::core::option::Option<FeedConfig>,
    /// Unix timestamp of when the update started.
    #[prost(int64, tag = "4")]
    pub started_at_ms: i64,
    /// Unix timestamp of when the update finished.
    /// Only populated if the update is finished.
    #[prost(int64, optional, tag = "6")]
    pub finished_at_ms: ::core::option::Option<i64>,
    /// Total latency of the feed update, in milliseconds.
    #[prost(int64, optional, tag = "20")]
    pub total_latency_ms: ::core::option::Option<i64>,
    /// Latency of the HTTP request, in milliseconds.
    #[prost(int64, optional, tag = "21")]
    pub download_latency_ms: ::core::option::Option<i64>,
    /// Latency of parsing the downloaded data, in milliseconds.
    #[prost(int64, optional, tag = "22")]
    pub parse_latency_ms: ::core::option::Option<i64>,
    /// Latency of updating the database with the parsed data, in milliseconds.
    #[prost(int64, optional, tag = "25")]
    pub database_latency_ms: ::core::option::Option<i64>,
    /// Status code returned by the HTTP request.
    #[prost(int32, optional, tag = "26")]
    pub download_http_status_code: ::core::option::Option<i32>,
    /// Status of the update.
    #[prost(enumeration = "feed_update::Status", tag = "7")]
    pub status: i32,
    /// Number of bytes in the downloaded feed data.
    /// Only populated if the update successfully downloaded data.
    #[prost(int32, optional, tag = "8")]
    pub content_length: ::core::option::Option<i32>,
    /// Hash of the downloaded feed data. This is used to skip updates
    /// if the feed data hasn't changed.
    /// Only populated if the update successfully downloaded data.
    #[prost(string, optional, tag = "9")]
    pub content_hash: ::core::option::Option<::prost::alloc::string::String>,
    /// Error message of the update.
    /// Only populated if the update finished in an error
    #[prost(string, optional, tag = "10")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FeedUpdate`.
pub mod feed_update {
    /// Status of a feed update.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Unknown status.
        Unknown = 0,
        /// Feed update is in progress. Currently this status never appears in the admin API, but is
        /// added in case Transiter support async feed updates in the future.
        Running = 1,
        /// Finished successfully.
        Updated = 2,
        /// The update was skipped because the downloaded data was identical to the data for the last successful update.
        Skipped = 3,
        /// Failed to download feed data.
        FailedDownloadError = 4,
        /// Feed data was empty.
        FailedEmptyFeed = 5,
        /// The feed configuration is invalid. This typically indicates a bug in Transiter because
        /// the feed configuration is validated when the system is being installed.
        FailedInvalidFeedConfig = 6,
        /// Failed to parse the feed data.
        /// This means the feed data was corrupted or otherwise invalid.
        FailedParseError = 8,
        /// Failed to update the database using the new feed data.
        /// This typically indicates a bug in Transiter or a transient error connecting to the database.
        FailedUpdateError = 9,
        /// An internal unspecified error occurred.
        FailedInternalError = 10,
        /// The feed has an unknown type.
        FailedUnknownFeedType = 11,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unknown => "UNKNOWN",
                Status::Running => "RUNNING",
                Status::Updated => "UPDATED",
                Status::Skipped => "SKIPPED",
                Status::FailedDownloadError => "FAILED_DOWNLOAD_ERROR",
                Status::FailedEmptyFeed => "FAILED_EMPTY_FEED",
                Status::FailedInvalidFeedConfig => "FAILED_INVALID_FEED_CONFIG",
                Status::FailedParseError => "FAILED_PARSE_ERROR",
                Status::FailedUpdateError => "FAILED_UPDATE_ERROR",
                Status::FailedInternalError => "FAILED_INTERNAL_ERROR",
                Status::FailedUnknownFeedType => "FAILED_UNKNOWN_FEED_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "RUNNING" => Some(Self::Running),
                "UPDATED" => Some(Self::Updated),
                "SKIPPED" => Some(Self::Skipped),
                "FAILED_DOWNLOAD_ERROR" => Some(Self::FailedDownloadError),
                "FAILED_EMPTY_FEED" => Some(Self::FailedEmptyFeed),
                "FAILED_INVALID_FEED_CONFIG" => Some(Self::FailedInvalidFeedConfig),
                "FAILED_PARSE_ERROR" => Some(Self::FailedParseError),
                "FAILED_UPDATE_ERROR" => Some(Self::FailedUpdateError),
                "FAILED_INTERNAL_ERROR" => Some(Self::FailedInternalError),
                "FAILED_UNKNOWN_FEED_TYPE" => Some(Self::FailedUnknownFeedType),
                _ => None,
            }
        }
    }
}
/// Response payload for the update feed endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeedReply {
    /// Information about the feed update that was performed.
    #[prost(message, optional, tag = "1")]
    pub feed_update: ::core::option::Option<FeedUpdate>,
}
/// Request payload for the get scheduler status endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulerStatusRequest {}
/// Response payload for the get scheduler status endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulerStatusReply {
    /// Status for all feeds being updated by the scheduler.
    #[prost(message, repeated, tag = "1")]
    pub feeds: ::prost::alloc::vec::Vec<get_scheduler_status_reply::FeedStatus>,
}
/// Nested message and enum types in `GetSchedulerStatusReply`.
pub mod get_scheduler_status_reply {
    /// Description of the status of one feed.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeedStatus {
        /// ID of the system this feed belongs to.
        #[prost(string, tag = "1")]
        pub system_id: ::prost::alloc::string::String,
        /// Configuration of the feed as used by the scheduler.
        /// If Postgres is manually updated to change the feed configuration,
        /// this may be different what's in Postgres.
        /// The scheduler needs to be updated in this case.
        /// In general, however, the feed config here will match what's in Postgres.
        #[prost(message, optional, tag = "7")]
        pub feed_config: ::core::option::Option<super::FeedConfig>,
        /// Unix timestamp of the last successful feed update.
        #[prost(int64, tag = "4")]
        pub last_successful_update: i64,
        /// Unix timestamp of the last finished update.
        #[prost(int64, tag = "5")]
        pub last_finished_update: i64,
        /// Whether a feed update for this feed is currently running.
        #[prost(bool, tag = "6")]
        pub currently_running: bool,
    }
}
/// Request payload for the reset scheduler endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetSchedulerRequest {}
/// Response payload for the reset scheduler endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetSchedulerReply {}
/// Request payload for the get log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogLevelRequest {}
/// Response payload for the get log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogLevelReply {
    /// Current log level.
    #[prost(enumeration = "LogLevel", tag = "2")]
    pub log_level: i32,
}
/// Request payload for the set log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLogLevelRequest {
    /// New log level.
    #[prost(enumeration = "LogLevel", tag = "2")]
    pub log_level: i32,
}
/// Response payload for the set log level endpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLogLevelReply {}
/// Supported log levels in Transiter.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    Info = 0,
    Debug = 1,
    Warn = 2,
    Error = 3,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogLevel::Info => "INFO",
            LogLevel::Debug => "DEBUG",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFO" => Some(Self::Info),
            "DEBUG" => Some(Self::Debug),
            "WARN" => Some(Self::Warn),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
